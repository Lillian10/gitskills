<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<link rel="stylesheet" type="text/css" href="" />

<title>redis / redisStudy</title>

<style>

body{
	margin: 0;
	padding: 0 15% 0 15%;
}

dl{
	float: center;
}

dt{
	margin: 1em 0 1em 0;
	padding: 10pt;
	background-color: lightgrey;
	font-size: 17pt;
	font-family: Arial, Georgia, Tahoma, Verdana, Sans-Serif, Helvetica;
}

dd{
	margin: 0 0 0 10pt;
	border: 0 inset gray;
}

</style>

</head>

<body>

<dl>
<dt>redisStudy</dt>
<dd>......</dd>

<dt>Redis简介</dt>
<dd>
<p>
<span style="font-family: 宋体; font-size: 11pt; color: #000000">redis是一个开源的，使用ANSI&nbsp;C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</span></p>
<p>
<span>它通常被称为&nbsp;数据结构服务器，因为值（value）可以是：&nbsp;字符串(String),&nbsp;哈希(Map),&nbsp;列表(list),&nbsp;集合(sets)&nbsp;和&nbsp;有序集合(sorted&nbsp;sets)等类型。</span></p>
<p>
<span>redis的官网地址，非常好记，是redis.io。（域名后缀io属于国家域名，是british&nbsp;Indian&nbsp;Ocean&nbsp;territory，即英属印度洋领地）</span></p>
<p>
<span>目前，Vmware在资助着redis项目的开发和维护。</span></p>
<p>
<span>redis作者Salvatore&nbsp;Sanfilippo，网名是antirez，博客&nbsp;</span>
<a href="http://antirez.com">antirez.com</a>
<span style="font-family: 宋体; font-size: 11pt; color: #000000">&nbsp;,他的github地址&nbsp;</span>
<a href="http://github.com/antirez">github.com/antirez</a>
<span style="font-family: 宋体; font-size: 11pt; color: #000000">。</span></p>
<p>
<span>----------------------------------------</span></p>
<p>
<span>Redis&nbsp;与其他&nbsp;key&nbsp;-&nbsp;value&nbsp;缓存产品有以下三个特点：</span></p>
<p>
<span>1.&nbsp;redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</span></p>
<p>
<span>2.&nbsp;Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</span></p>
<p>
<span>3.&nbsp;Redis支持数据的备份，即master-slave模式的数据备份。</span></p>
<p></p></dd>

<dt>linux下安装redis和启动</dt>
<dd>
<p>
<span style="font-family: 宋体; font-size: 11pt; color: #000000">redis官方网址</span></p>
<p>
<a href="http://redis.io/">http://redis.io/</a></p>
<p>
<span>本次以redis-2.8.15为例。</span></p>
<p>
<span>一&nbsp;下载redis</span></p>
<p>
<span>下载到的目录必须是有写权限的目录。</span></p>
<p>
<span>[yanli@FirstPro&nbsp;Downloads]%HTML_CONTENT%nbsp;wget&nbsp;</span>
<a href="http://download.redis.io/releases/redis-2.8.15.tar.gz">http://download.redis.io/releases/redis-2.8.15.tar.gz</a></p>
<p>
<span>--2016-01-20&nbsp;15:01:54--&nbsp;&nbsp;</span>
<a href="http://download.redis.io/releases/redis-2.8.15.tar.gz">http://download.redis.io/releases/redis-2.8.15.tar.gz</a></p>
<p>
<span>Resolving&nbsp;download.redis.io...&nbsp;109.74.203.151</span></p>
<p>
<span>Connecting&nbsp;to&nbsp;download.redis.io|109.74.203.151|:80...&nbsp;connected.</span></p>
<p>
<span>HTTP&nbsp;request&nbsp;sent,&nbsp;awaiting&nbsp;response...&nbsp;200&nbsp;OK</span></p>
<p>
<span>Length:&nbsp;1233621&nbsp;(1.2M)&nbsp;[application/x-gzip]</span></p>
<p>
<span>Saving&nbsp;to:&nbsp;&quot;redis-2.8.15.tar.gz&quot;</span></p>
<p></p>
<p>
<span>100%[=====================================&gt;]&nbsp;1,233,621&nbsp;&nbsp;&nbsp;58.0K/s&nbsp;&nbsp;&nbsp;in&nbsp;18s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p></p>
<p>
<span>2016-01-20&nbsp;15:02:15&nbsp;(66.5&nbsp;KB/s)&nbsp;-&nbsp;&quot;redis-2.8.15.tar.gz&quot;&nbsp;saved&nbsp;[1233621/1233621]</span></p>
<p></p>
<p>
<span>[yanli@FirstPro&nbsp;Downloads]%HTML_CONTENT%nbsp;</span></p>
<p></p>
<p>
<span>二&nbsp;解压redis&nbsp;tar包</span></p>
<p>
<span>%HTML_CONTENT%nbsp;tar&nbsp;-zxvf&nbsp;redis-2.8.15.tar.gz</span></p>
<p></p>
<p>
<span>三&nbsp;编译</span></p>
<p>
<span>%HTML_CONTENT%nbsp;cd&nbsp;redis-2.8.15</span></p>
<p>
<span>%HTML_CONTENT%nbsp;make</span></p>
<p>
<span>make完后&nbsp;redis-2.8.17目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli,两个程序位于安装目录&nbsp;src&nbsp;目录下，另外还会产生一些二进制可执行文件。</span></p>
<p>
<span>[yanli@FirstPro&nbsp;src]%HTML_CONTENT%nbsp;find&nbsp;.&nbsp;-type&nbsp;f&nbsp;-executable</span></p>
<p>
<span>./mkreleasehdr.sh</span></p>
<p>
<span>./redis-sentinel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//用于集群管理</span></p>
<p>
<span>./redis-benchmark&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//用于进行redis性能测试的工具</span></p>
<p>
<span>./redis-check-dump&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//用于修复出问题的dump.rdb文件</span></p>
<p>
<span>./redis-server&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//redis的服务端</span></p>
<p>
<span>./redis-cli&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//redis的客户端</span></p>
<p>
<span>./redis-check-aof&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//用于修复出问题的AOF文件</span></p>
<p>
<span>[yanli@FirstPro&nbsp;src]%HTML_CONTENT%nbsp;</span></p>
<p></p>
<p>
<span>四&nbsp;启动redis</span></p>
<p>
<span>[yanli@FirstPro&nbsp;redis-2.8.15]%HTML_CONTENT%nbsp;cd&nbsp;src</span></p>
<p>
<span>[yanli@FirstPro&nbsp;src]%HTML_CONTENT%nbsp;./redis-server</span></p>
<p>
<span>启动是前台启动，会占用控制台页面。需要进行其他操作，必须重新开一个窗口。</span></p>
<p>
<span>注意这种方式启动redis&nbsp;使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。</span></p>
<p>
<span>%HTML_CONTENT%nbsp;./redis-server&nbsp;../redis.conf</span></p>
<p>
<span>默认情况下，redis-server会以非daemon的方式来运行，且默认服务端口为6379。</span></p>
<p>
<span>//通过客户端来关闭redis服务端</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;shutdown&nbsp;</span></p>
<p></p>
<p>
<span>五&nbsp;在远程服务器上执行命令</span></p>
<p>
<span>如果需要在远程&nbsp;redis&nbsp;服务上执行命令，同样我们使用的也是&nbsp;redis-cli&nbsp;命令。</span></p>
<p>
<span>%HTML_CONTENT%nbsp;redis-cli&nbsp;-h&nbsp;host&nbsp;-p&nbsp;port&nbsp;-a&nbsp;password</span></p>
<p>
<span>测试用例：</span></p>
<p>
<img src="img_18988.bmp"></img></p>
<p>
<span>执行&nbsp;PING&nbsp;命令，该命令用于检测&nbsp;redis&nbsp;服务是否启动。</span></p>
<p></p>
<p></p>
<ul id="ID_PictFileNames" style="display: none">
<li fn="img_18988.bmp"></li></ul></dd>

<dt>Redis配置</dt>
<dd>
<p>
<span style="font-family: 宋体; font-size: 11pt; color: #000000">Redis&nbsp;的配置文件位于&nbsp;Redis&nbsp;安装目录下，文件名为&nbsp;redis.conf。</span></p>
<p>
<span>通过&nbsp;CONFIG&nbsp;命令查看或设置配置项。</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;CONFIG&nbsp;GET&nbsp;loglevel</span></p>
<p>
<span>1)&nbsp;&quot;loglevel&quot;</span></p>
<p>
<span>2)&nbsp;&quot;notice&quot;</span></p>
<p></p>
<p>
<span>使用&nbsp;*&nbsp;号获取所有配置项：redis&nbsp;127.0.0.1:6379&gt;&nbsp;CONFIG&nbsp;GET&nbsp;*</span></p>
<p>
<span>----------------------------------------</span></p>
<p></p>
<p>
<span style="font-weight: bold">编辑配置</span></p>
<p>
<span>通过修改&nbsp;redis.conf&nbsp;文件或使用&nbsp;CONFIG&nbsp;set&nbsp;命令来修改配置。</span></p>
<p>
<span>CONFIG&nbsp;SET&nbsp;命令基本语法：redis&nbsp;127.0.0.1:6379&gt;&nbsp;CONFIG&nbsp;SET&nbsp;CONFIG_SETTING_NAME&nbsp;NEW_CONFIG_VALUE</span></p>
<p></p>
<p>
<span>实例</span></p>
<p>
<img src="img_2951.bmp"></img></p>
<p>
<span>----------------------------------------</span></p>
<p></p>
<p>
<span style="font-weight: bold">参数说明</span></p>
<p>
<span>redis.conf&nbsp;配置项说明如下：</span></p>
<p>
<span>1.&nbsp;Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">daemonize&nbsp;no</span></p>
<p>
<span>2.&nbsp;当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">pidfile&nbsp;/var/run/redis.pid</span></p>
<p>
<span>3.&nbsp;指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia&nbsp;Merz的名字</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">port&nbsp;6379</span></p>
<p>
<span>4.&nbsp;绑定的主机地址</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">&nbsp;bind&nbsp;127.0.0.1</span></p>
<p>
<span>5.当&nbsp;客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">timeout&nbsp;300</span></p>
<p>
<span>6.&nbsp;指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">loglevel&nbsp;verbose</span></p>
<p>
<span>7.&nbsp;日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">logfile&nbsp;stdout</span></p>
<p>
<span>8.&nbsp;设置数据库的数量，默认数据库为0，可以使用SELECT&nbsp;&lt;dbid&gt;命令在连接上指定数据库id</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">databases&nbsp;16</span></p>
<p>
<span>9.&nbsp;指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">save</span>
<span style="color: #000000">&nbsp;&lt;seconds&gt;&nbsp;&lt;changes&gt;</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;Redis默认配置文件中提供了三个条件：</span></p>
<p>
<span>&nbsp;&nbsp;</span>
<span style="color: #ff0000">&nbsp;&nbsp;save&nbsp;900&nbsp;1</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;save&nbsp;300&nbsp;10</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;save&nbsp;60&nbsp;10000</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</span></p>
<p>
<span>&nbsp;</span></p>
<p>
<span>10.&nbsp;指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">&nbsp;rdbcompression&nbsp;yes</span></p>
<p>
<span>11.&nbsp;指定本地数据库文件名，默认值为dump.rdb</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">dbfilename&nbsp;dump.rdb</span></p>
<p>
<span>12.&nbsp;指定本地数据库存放目录</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">dir&nbsp;./</span></p>
<p>
<span>13.&nbsp;设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">slaveof&nbsp;&lt;masterip&gt;&nbsp;&lt;masterport&gt;</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;默认是禁掉的。</span></p>
<p>
<span>14.&nbsp;当master服务设置了密码保护时，slav服务连接master的密码</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">masterauth&nbsp;&lt;master-password&gt;</span></p>
<p>
<span>15.&nbsp;设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH&nbsp;&lt;password&gt;命令提供密码，默认关闭</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">requirepass&nbsp;foobared</span></p>
<p>
<span>16.&nbsp;设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置&nbsp;maxclients&nbsp;0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max&nbsp;number&nbsp;of&nbsp;clients&nbsp;reached错误信息</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">maxclients&nbsp;128</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;这里提到的客户端数，应该是不同ip的链接。不是指开启的操作界面的数量。</span></p>
<p>
<span>17.&nbsp;指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理&nbsp;后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">maxmemory&nbsp;&lt;bytes&gt;</span></p>
<p>
<span>18.&nbsp;指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为&nbsp;redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">appendonly&nbsp;no</span></p>
<p>
<span>19.&nbsp;指定更新日志文件名，默认为appendonly.aof</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">appendfilename&nbsp;appendonly.aof</span></p>
<p>
<span>20.&nbsp;指定更新日志条件，共有3个可选值：&nbsp;</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">no</span>
<span style="color: #000000">：表示等操作系统进行数据缓存同步到磁盘（快）&nbsp;</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">always</span>
<span style="color: #000000">：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）&nbsp;</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">everysec</span>
<span style="color: #000000">：表示每秒同步一次（折衷，默认值）</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">appendfsync&nbsp;</span>
<span style="color: #000000">everysec</span></p>
<p></p>
<p>
<span>21.&nbsp;指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中**</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vm-enabled&nbsp;no</span></p>
<p>
<span>22.&nbsp;虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vm-swap-file&nbsp;/tmp/redis.swap</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;查看redis.conf并没有此参数。</span></p>
<p>
<span>23.&nbsp;将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据&nbsp;就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vm-max-memory&nbsp;0</span></p>
<p>
<span>24.&nbsp;Redis&nbsp;swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的&nbsp;数据大小来设定的，</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;编者建议：</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;（1）如果存储很多小对象，page大小最好设置为32或者64bytes；</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;（2）如果存储很大大对象，则可以使用更大的page，</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;（3）如果不&nbsp;确定，就使用默认值</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vm-page-size&nbsp;32</span></p>
<p>
<span>25.&nbsp;设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vm-pages&nbsp;134217728</span></p>
<p>
<span>26.&nbsp;设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vm-max-threads&nbsp;4</span></p>
<p>
<span>27.&nbsp;设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;glueoutputbuf&nbsp;yes</span></p>
<p>
<span>28.&nbsp;指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;hash-max-zipmap-entries&nbsp;64</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;hash-max-zipmap-value&nbsp;512</span></p>
<p>
<span>29.&nbsp;指定是否激活重置哈希，默认为开启</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">activerehashing&nbsp;yes</span></p>
<p>
<span>30.&nbsp;指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">include&nbsp;/path/to/local.conf</span></p>
<p>
<span>PS&nbsp;vm相关参数在默认的redis.conf是没有的。启动内存机制才会有的？</span></p>
<p></p>
<ul id="ID_PictFileNames" style="display: none">
<li fn="img_2951.bmp"></li></ul></dd>

<dt>Redis键命令</dt>
<dd>
<p>
<span style="font-family: 宋体; font-size: 11pt; color: #000000">用于管理redis的键。</span></p>
<p>
<span>测试用例：</span></p>
<p>
<span style="font-style: italic">127.0.0.1:6379&gt;&nbsp;set&nbsp;s3ckey&nbsp;ok</span></p>
<p>
<span>OK</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;get&nbsp;s3ckey</span></p>
<p>
<span>&quot;ok&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;del&nbsp;s3ckey&nbsp;&nbsp;&nbsp;//键被删除成功，命令执行后输出&nbsp;(integer)&nbsp;1，否则将输出&nbsp;(integer)&nbsp;0</span></p>
<p>
<span>(integer)&nbsp;1</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;get&nbsp;s3ckey</span></p>
<p>
<span>(nil)</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;keys&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//查询当前数据库中所有的key</span></p>
<p></p>
<p>
<span>Redis&nbsp;键相关的基本命令：</span></p>
<p>
<span>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">DEL&nbsp;key</span></p>
<p>
<span>该命令用于在&nbsp;key&nbsp;存在是删除&nbsp;key。</span></p>
<p>
<span>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">DUMP&nbsp;key&nbsp;</span></p>
<p>
<span>序列化给定&nbsp;key&nbsp;，并返回被序列化的值。</span></p>
<p>
<span>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">EXISTS&nbsp;key&nbsp;</span></p>
<p>
<span>检查给定&nbsp;key&nbsp;是否存在。</span></p>
<p>
<span>4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">EXPIRE&nbsp;key&nbsp;seconds</span></p>
<p>
<span>为给定&nbsp;key&nbsp;设置过期时间。</span></p>
<p>
<span>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">EXPIREAT&nbsp;key&nbsp;timestamp&nbsp;</span></p>
<p>
<span>EXPIREAT&nbsp;的作用和&nbsp;EXPIRE&nbsp;类似，都用于为&nbsp;key&nbsp;设置过期时间。&nbsp;不同在于&nbsp;EXPIREAT&nbsp;命令接受的时间参数是&nbsp;UNIX&nbsp;时间戳(unix&nbsp;timestamp)。</span></p>
<p>
<span>6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">PEXPIRE&nbsp;key&nbsp;milliseconds&nbsp;</span></p>
<p>
<span>设置&nbsp;key&nbsp;的过期时间亿以毫秒计。</span></p>
<p>
<span>7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">PEXPIREAT&nbsp;key&nbsp;milliseconds-timestamp&nbsp;</span></p>
<p>
<span>设置&nbsp;key&nbsp;过期时间的时间戳(unix&nbsp;timestamp)&nbsp;以毫秒计</span></p>
<p>
<span>8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">KEYS&nbsp;pattern</span>
<span style="color: #000000">&nbsp;</span></p>
<p>
<span>查找所有符合给定模式(&nbsp;pattern)的&nbsp;key&nbsp;。</span></p>
<p>
<span>9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">MOVE&nbsp;key&nbsp;db&nbsp;</span></p>
<p>
<span>将当前数据库的&nbsp;key&nbsp;移动到给定的数据库&nbsp;db&nbsp;当中。</span></p>
<p>
<span>10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">PERSIST&nbsp;key&nbsp;</span></p>
<p>
<span>移除&nbsp;key&nbsp;的过期时间，key&nbsp;将持久保持。</span></p>
<p>
<span>11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">PTTL&nbsp;key&nbsp;</span></p>
<p>
<span>以毫秒为单位返回&nbsp;key&nbsp;的剩余的过期时间。</span></p>
<p>
<span>12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">TTL&nbsp;key&nbsp;</span></p>
<p>
<span>以秒为单位，返回给定&nbsp;key&nbsp;的剩余生存时间(TTL,&nbsp;time&nbsp;to&nbsp;live)。</span></p>
<p>
<span>当&nbsp;key&nbsp;不存在时，返回&nbsp;-2&nbsp;。</span></p>
<p>
<span>当&nbsp;key&nbsp;存在但没有设置剩余生存时间时，返回&nbsp;-1&nbsp;。</span></p>
<p>
<span>否则，以秒为单位，返回&nbsp;key&nbsp;的剩余生存时间。</span></p>
<p></p>
<p>
<span>13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">RANDOMKEY&nbsp;</span></p>
<p>
<span>从当前数据库中随机返回一个&nbsp;key&nbsp;。</span></p>
<p>
<span>14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">RENAME&nbsp;key&nbsp;newkey&nbsp;</span></p>
<p>
<span>修改&nbsp;key&nbsp;的名称</span></p>
<p>
<span>15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">RENAMENX&nbsp;key&nbsp;newkey&nbsp;</span></p>
<p>
<span>仅当&nbsp;newkey&nbsp;不存在时，将&nbsp;key&nbsp;改名为&nbsp;newkey&nbsp;。</span></p>
<p>
<span>16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">TYPE&nbsp;key&nbsp;</span></p>
<p>
<span>返回&nbsp;key&nbsp;所储存的值的类型。</span></p>
<p>
<span>17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<span style="color: #ff0000">Keys&nbsp;*</span></p>
<p>
<span>返回当前数据库中所有的key</span></p>
<p></p>
<p></p></dd>

<dt>redis数据结构</dt>
<dd>
<p>
<span style="font-family: 宋体; font-size: 11pt; font-weight: bold; color: #000000">简介</span></p>
<p>
<span>redis是一种高级的key:value存储系统，其中value支持五种数据类型：</span></p>
<p></p>
<p>
<span>字符串（strings）</span></p>
<p>
<span>字符串列表（lists）</span></p>
<p>
<span>字符串集合（sets）</span></p>
<p>
<span>有序字符串集合（sorted&nbsp;sets）</span></p>
<p>
<span>哈希（hashes）</span></p>
<p></p>
<p>
<span>关于key，需要注意：</span></p>
<p>
<span>key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率；</span></p>
<p>
<span>key也不要太短，太短的话，key的可读性会降低；</span></p>
<p>
<span>在一个项目中，key最好使用统一的命名模式，例如user:10000:passwd。</span></p>
<p>
<span>----------------------------------------</span></p>
<p></p>
<p>
<span style="font-weight: bold">redis数据结构&nbsp;-&nbsp;strings</span></p>
<p>
<span>string是redis最基本的类型，可以理解成与Memcached一模一样的类型，一个key对应一个value。</span></p>
<p>
<span>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象&nbsp;。</span></p>
<p>
<span>string类型是Redis最基本的数据类型，一个键最大能存储512MB。</span></p>
<p></p>
<p>
<span>测试用例：</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;set&nbsp;w3ckey&nbsp;redis&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设置指定&nbsp;key&nbsp;的值</span></p>
<p>
<span>OK</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;get&nbsp;w3ckey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取指定&nbsp;key&nbsp;的值</span></p>
<p>
<span>&quot;redis&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;getrange&nbsp;w3ckey&nbsp;1&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//返回&nbsp;key&nbsp;中字符串值的子字符,从0计数</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;getrange&nbsp;w3ckey&nbsp;0&nbsp;2</span></p>
<p>
<span>&quot;red&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;getrange&nbsp;w3ckey&nbsp;0&nbsp;3</span></p>
<p>
<span>&quot;redi&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;getrange&nbsp;w3ckey&nbsp;0&nbsp;4</span></p>
<p>
<span>&quot;redis&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;getrange&nbsp;w3ckey&nbsp;0&nbsp;5</span></p>
<p>
<span>&quot;redis&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;getrange&nbsp;w3ckey&nbsp;0&nbsp;6</span></p>
<p>
<span>&quot;redis&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;getset&nbsp;w3ckey&nbsp;mem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//将给定&nbsp;key&nbsp;的值设为&nbsp;value&nbsp;，并返回&nbsp;key&nbsp;的旧值(old&nbsp;value)。</span></p>
<p>
<span>&quot;redis&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;get&nbsp;w3ckey</span></p>
<p>
<span>&quot;mem&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;set&nbsp;name&nbsp;huahua</span></p>
<p>
<span>OK</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;mget&nbsp;name&nbsp;w3ckey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取所有(一个或多个)给定&nbsp;key&nbsp;的值。</span></p>
<p>
<span>1)&nbsp;&quot;huahua&quot;</span></p>
<p>
<span>2)&nbsp;&quot;mem&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;setex&nbsp;age&nbsp;60&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//将值&nbsp;value&nbsp;关联到&nbsp;key&nbsp;，并将&nbsp;key&nbsp;的过期时间设为&nbsp;seconds&nbsp;(以秒为单位)。</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//把age值设为12，过期时间设为60秒，如果过期了，这个age将不存在。</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;keys&nbsp;*</span></p>
<p>
<span>1)&nbsp;&quot;age&quot;</span></p>
<p>
<span>2)&nbsp;&quot;w3ckey&quot;</span></p>
<p>
<span>3)&nbsp;&quot;name&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;keys&nbsp;*</span></p>
<p>
<span>1)&nbsp;&quot;w3ckey&quot;</span></p>
<p>
<span>2)&nbsp;&quot;name&quot;</span></p>
<p>
<span>PSETEX&nbsp;key&nbsp;milliseconds&nbsp;value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//这个命令和&nbsp;SETEX&nbsp;命令相似，但它以毫秒为单位设置&nbsp;key&nbsp;的生存时间，而不是像&nbsp;SETEX&nbsp;命令那样，以秒为单位。</span></p>
<p></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;setnx&nbsp;name&nbsp;test&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//只有在&nbsp;key&nbsp;不存在时设置&nbsp;key&nbsp;的值。已经存在的key，将设置不成功</span></p>
<p>
<span>(integer)&nbsp;0</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;get&nbsp;name</span></p>
<p>
<span>&quot;huahua&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;setnx&nbsp;age&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p>
<span>(integer)&nbsp;1</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;get&nbsp;age</span></p>
<p>
<span>&quot;10&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;setrange&nbsp;name&nbsp;0&nbsp;&nbsp;mmm&nbsp;&nbsp;&nbsp;//用&nbsp;value&nbsp;参数覆写给定&nbsp;key&nbsp;所储存的字符串值，从偏移量&nbsp;offset&nbsp;开始</span></p>
<p>
<span>(integer)&nbsp;6</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;get&nbsp;name</span></p>
<p>
<span>&quot;mmmhua&quot;</span></p>
<p></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;get&nbsp;w3ckey</span></p>
<p>
<span>&quot;mem&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;strlen&nbsp;w3ckey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//返回&nbsp;key&nbsp;所储存的字符串值的长度</span></p>
<p>
<span>(integer)&nbsp;3</span></p>
<p></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;mset&nbsp;key1&nbsp;test1&nbsp;key2&nbsp;test2&nbsp;key3&nbsp;test3&nbsp;&nbsp;//同时设置一个或多个&nbsp;key-value&nbsp;对</span></p>
<p>
<span>OK</span></p>
<p></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;mset&nbsp;key1&nbsp;abc&nbsp;key4&nbsp;abc4&nbsp;&nbsp;&nbsp;//mset设置&nbsp;会把已有的key值改变</span></p>
<p>
<span>OK</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;get&nbsp;key1</span></p>
<p>
<span>&quot;abc&quot;</span></p>
<p></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;msetnx&nbsp;key4&nbsp;abcnx&nbsp;key5&nbsp;abcnx5&nbsp;&nbsp;&nbsp;//同时设置一个或多个&nbsp;key-value&nbsp;对，当且仅当所有给定&nbsp;key&nbsp;都不存在。</span></p>
<p>
<span>(integer)&nbsp;0</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;get&nbsp;key4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//key4存在，设置不成功；而且key5也会设置不成功，key4还是原来的值，key5&nbsp;为空</span></p>
<p>
<span>&quot;abc4&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;get&nbsp;key5</span></p>
<p>
<span>(nil)</span></p>
<p></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;incr&nbsp;age&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//将&nbsp;key&nbsp;中储存的数字值增一</span></p>
<p>
<span>(integer)&nbsp;11</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;incr&nbsp;key1</span></p>
<p>
<span>(error)&nbsp;ERR&nbsp;value&nbsp;is&nbsp;not&nbsp;an&nbsp;integer&nbsp;or&nbsp;out&nbsp;of&nbsp;range</span></p>
<p></p>
<p></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;incrby&nbsp;age&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//将&nbsp;key&nbsp;所储存的值加上给定的增量值（increment）</span></p>
<p>
<span>(integer)&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//不可以增加浮点数</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;incrby&nbsp;key1&nbsp;3</span></p>
<p>
<span>(error)&nbsp;ERR&nbsp;value&nbsp;is&nbsp;not&nbsp;an&nbsp;integer&nbsp;or&nbsp;out&nbsp;of&nbsp;range</span></p>
<p></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;incrby&nbsp;age&nbsp;0.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p>
<span>(error)&nbsp;ERR&nbsp;value&nbsp;is&nbsp;not&nbsp;an&nbsp;integer&nbsp;or&nbsp;out&nbsp;of&nbsp;range</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;incrbyfloat&nbsp;age&nbsp;0.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//将&nbsp;key&nbsp;所储存的值加上给定的浮点增量值（increment）</span></p>
<p>
<span>&quot;14.5&quot;</span></p>
<p></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;get&nbsp;key1</span></p>
<p>
<span>&quot;abc&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;append&nbsp;key1&nbsp;def&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//如果&nbsp;key&nbsp;已经存在并且是一个字符串，&nbsp;APPEND&nbsp;命令将&nbsp;value&nbsp;追加到&nbsp;key&nbsp;原来的值的末尾</span></p>
<p>
<span>(integer)&nbsp;6</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;get&nbsp;key1</span></p>
<p>
<span>&quot;abcdef&quot;</span></p>
<p></p>
<p>
<span>DECR&nbsp;key</span></p>
<p>
<span>将&nbsp;key&nbsp;中储存的数字值减一。</span></p>
<p>
<span>DECRBY&nbsp;key&nbsp;decrement</span></p>
<p>
<span>key&nbsp;所储存的值减去给定的减量值（decrement）&nbsp;。</span></p>
<p></p>
<p>
<span>注意：</span></p>
<p>
<span>在遇到数值操作时，redis会将字符串类型转换成数值。</span></p>
<p>
<span>由于INCR等指令本身就具有原子操作的特性，所以我们完全可以利用redis的INCR、INCRBY、DECR、DECRBY等指令来实现原子计数的效果。</span></p>
<p>
<span>假如，在某种场景下有3个客户端同时读取了mynum的值（值为2），然后对其同时进行了加1的操作，那么，最后mynum的值一定是5。</span></p>
<p></p>
<p>
<span>----------------------------------------</span></p>
<p></p>
<p>
<span style="font-weight: bold">redis数据结构&nbsp;-&nbsp;Hash</span></p>
<p>
<span>Redis&nbsp;hash&nbsp;是一个键值对集合。</span></p>
<p>
<span>Redis&nbsp;hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</span></p>
<p>
<span>每个&nbsp;hash&nbsp;可以存储&nbsp;2</span>
<span style="vertical-align: super">32&nbsp;-&nbsp;1</span>
<span>&nbsp;键值对（40多亿）。</span></p>
<p></p>
<p>
<span>实例：</span></p>
<p>
<span>1.如果哈希表不存在，一个新的哈希表被创建并进行&nbsp;HSET&nbsp;操作。</span></p>
<p>
<span>&nbsp;&nbsp;如果字段已经存在于哈希表中，旧值将被覆盖。</span></p>
<p>
<span>返回值：如果字段是哈希表中的一个新建字段，并且值设置成功，返回&nbsp;1&nbsp;。&nbsp;如果哈希表中域字段已经存在且旧值已被新值覆盖，返回&nbsp;0&nbsp;。</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;HSET&nbsp;myhash&nbsp;field1&nbsp;&quot;foo&quot;</span></p>
<p>
<span>(integer)&nbsp;1</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;HGET&nbsp;myhash&nbsp;field1</span></p>
<p>
<span>&quot;foo&quot;</span></p>
<p></p>
<p>
<span>2.Redis&nbsp;Hgetall&nbsp;命令用于返回哈希表中，所有的字段和值。</span></p>
<p>
<span>在返回值里，紧跟每个字段名(field&nbsp;name)之后是字段的值(value)，所以返回值的长度是哈希表大小的两倍。</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;hgetall&nbsp;myhash</span></p>
<p>
<span>1)&nbsp;&quot;field1&quot;</span></p>
<p>
<span>2)&nbsp;&quot;foo&quot;</span></p>
<p>
<span>3)&nbsp;&quot;field2&quot;</span></p>
<p>
<span>4)&nbsp;&quot;hi&quot;</span></p>
<p></p>
<p>
<span>3.Redis&nbsp;Hdel&nbsp;命令用于删除哈希表&nbsp;key&nbsp;中的一个或多个指定字段，不存在的字段将被忽略。</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;HDEL&nbsp;myhash&nbsp;field2</span></p>
<p>
<span>(integer)&nbsp;1</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;HDEL&nbsp;myhash&nbsp;field2</span></p>
<p>
<span>(integer)&nbsp;0</span></p>
<p></p>
<p>
<span>4.判断某个字段是否存在，存在返回1，不存在返回0.</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;HEXISTS&nbsp;myhash&nbsp;field2</span></p>
<p>
<span>(integer)&nbsp;0</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;HEXISTS&nbsp;myhash&nbsp;field1</span></p>
<p>
<span>(integer)&nbsp;1</span></p>
<p></p>
<p>
<span>5.&nbsp;Hkeys&nbsp;命令用于获取哈希表中的所有字段名</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;HKEYS&nbsp;myhash</span></p>
<p>
<span>1)&nbsp;&quot;field1&quot;</span></p>
<p>
<span>2)&nbsp;&quot;filed2&quot;</span></p>
<p></p>
<p>
<span>6.&nbsp;HINCRBY&nbsp;key&nbsp;field&nbsp;increment&nbsp;</span></p>
<p>
<span>为哈希表&nbsp;key&nbsp;中的指定字段的整数值加上增量&nbsp;increment&nbsp;。</span></p>
<p>
<span>7.&nbsp;HINCRBYFLOAT&nbsp;key&nbsp;field&nbsp;increment&nbsp;</span></p>
<p>
<span>为哈希表&nbsp;key&nbsp;中的指定字段的浮点数值加上增量&nbsp;increment&nbsp;。</span></p>
<p>
<span>8.&nbsp;HLEN&nbsp;key&nbsp;</span></p>
<p>
<span>获取哈希表中字段的数量</span></p>
<p>
<span>9.&nbsp;HMGET&nbsp;key&nbsp;field1&nbsp;[field2]&nbsp;</span></p>
<p>
<span>获取所有给定字段的值</span></p>
<p>
<span>10.&nbsp;HMSET&nbsp;key&nbsp;field1&nbsp;value1&nbsp;[field2&nbsp;value2&nbsp;]&nbsp;</span></p>
<p>
<span>同时将多个&nbsp;field-value&nbsp;(域-值)对设置到哈希表&nbsp;key&nbsp;中。</span></p>
<p>
<span>11.&nbsp;HSET&nbsp;key&nbsp;field&nbsp;value&nbsp;</span></p>
<p>
<span>将哈希表&nbsp;key&nbsp;中的字段&nbsp;field&nbsp;的值设为&nbsp;value&nbsp;。</span></p>
<p>
<span>12.&nbsp;HSETNX&nbsp;key&nbsp;field&nbsp;value&nbsp;</span></p>
<p>
<span>只有在字段&nbsp;field&nbsp;不存在时，设置哈希表字段的值。</span></p>
<p>
<span>13.&nbsp;HVALS&nbsp;key&nbsp;</span></p>
<p>
<span>获取哈希表中所有值</span></p>
<p></p>
<p>
<span>运用场景：</span></p>
<p>
<span>hashes存的是字符串和字符串值之间的映射，比如一个用户要存储其全名、姓氏、年龄等等，就很适合使用哈希。</span></p>
<p>
<img src="img_26010.bmp"></img></p>
<p></p>
<p>
<span>----------------------------------------------------------</span></p>
<p></p>
<p>
<span>redis数据结构&nbsp;-&nbsp;List</span></p>
<p>
<span>Redis&nbsp;列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导入列表的头部（左边）或者尾部（右边）。</span></p>
<p>
<span>列表最多可存储&nbsp;2</span>
<span style="vertical-align: super">32&nbsp;-&nbsp;1</span>
<span>&nbsp;元素&nbsp;(4294967295,&nbsp;每个列表可存储40多亿)。</span></p>
<p></p>
<p>
<span>实例：</span></p>
<p>
<span>1.&nbsp;LPUSH&nbsp;key&nbsp;value1&nbsp;[value2]&nbsp;</span></p>
<p>
<span>将一个或多个值插入到列表头部。</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;lpush&nbsp;w3ckey&nbsp;redis</span></p>
<p>
<span>(integer)&nbsp;1</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;keys&nbsp;*</span></p>
<p>
<span>1)&nbsp;&quot;w3ckey&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;get&nbsp;w3ckey&nbsp;&nbsp;&nbsp;&nbsp;//列表不能用字符串的get获取</span></p>
<p>
<span>(error)&nbsp;WRONGTYPE&nbsp;Operation&nbsp;against&nbsp;a&nbsp;key&nbsp;holding&nbsp;the&nbsp;wrong&nbsp;kind&nbsp;of&nbsp;value</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;lpush&nbsp;w3ckey&nbsp;mongodb&nbsp;mysql</span></p>
<p>
<span>(integer)&nbsp;3</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;lrange&nbsp;w3ckey&nbsp;0&nbsp;3&nbsp;&nbsp;//获取字符串</span></p>
<p>
<span>1)&nbsp;&quot;mysql&quot;</span></p>
<p>
<span>2)&nbsp;&quot;mongodb&quot;</span></p>
<p>
<span>3)&nbsp;&quot;redis&quot;</span></p>
<p></p>
<p>
<span>2.&nbsp;&nbsp;Blpop&nbsp;命令移出并获取列表的第一个元素，&nbsp;如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</span></p>
<p>
<span>返回值：如果列表为空，返回一个&nbsp;nil&nbsp;。&nbsp;否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的&nbsp;key&nbsp;，第二个元素是被弹出元素的值。</span></p>
<p>
<img src="img_1425.bmp"></img></p>
<p>
<img src="img_10845.bmp"></img></p>
<p>
<span>举例：</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;lrange&nbsp;w3ckey&nbsp;0&nbsp;5</span></p>
<p>
<span>1)&nbsp;&quot;mongodb&quot;</span></p>
<p>
<span>2)&nbsp;&quot;redis&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;blpop&nbsp;w3ckey&nbsp;1</span></p>
<p>
<span>1)&nbsp;&quot;w3ckey&quot;</span></p>
<p>
<span>2)&nbsp;&quot;mongodb&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;lrange&nbsp;w3ckey&nbsp;0&nbsp;5</span></p>
<p>
<span>1)&nbsp;&quot;redis&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;</span></p>
<p>
<span>一定注意，不要获取不存在的列表key，否则会阻塞，最后返回超时。或者等发现可弹出元素为之。</span></p>
<p></p>
<p>
<span>3.&nbsp;Brpop&nbsp;命令移出并获取列表的最后一个元素，&nbsp;如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</span></p>
<p>
<span>返回：假如在指定时间内没有任何元素被弹出，则返回一个&nbsp;nil&nbsp;和等待时长。&nbsp;反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的&nbsp;key&nbsp;，第二个元素是被弹出元素的值。</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;brpop&nbsp;w3ckey&nbsp;1</span></p>
<p>
<span>1)&nbsp;&quot;w3ckey&quot;</span></p>
<p>
<span>2)&nbsp;&quot;redis&quot;</span></p>
<p></p>
<p>
<span>4.&nbsp;BRPOPLPUSH&nbsp;source&nbsp;destination&nbsp;timeout&nbsp;</span></p>
<p>
<span>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它；&nbsp;如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</span></p>
<p>
<span>timeout这个参数经测试不起作用的。</span></p>
<p>
<span>将列表&nbsp;source&nbsp;中的最后一个元素(尾元素)弹出，并返回给客户端。</span></p>
<p>
<span>将&nbsp;source&nbsp;弹出的元素插入到列表&nbsp;destination&nbsp;，作为&nbsp;destination&nbsp;列表的的头元素。</span></p>
<p>
<img src="img_8307.bmp"></img></p>
<p></p>
<p>
<span>5.&nbsp;LINDEX&nbsp;key&nbsp;index&nbsp;</span></p>
<p>
<span>通过索引获取列表中的元素</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;lrange&nbsp;test&nbsp;0&nbsp;5</span></p>
<p>
<span>1)&nbsp;&quot;mysql&quot;</span></p>
<p>
<span>2)&nbsp;&quot;mongo&quot;</span></p>
<p>
<span>3)&nbsp;&quot;reids&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;lindex&nbsp;test&nbsp;1</span></p>
<p>
<span>&quot;mongo&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;lindex&nbsp;test&nbsp;0</span></p>
<p>
<span>&quot;mysql&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;lindex&nbsp;test&nbsp;3</span></p>
<p>
<span>(nil)</span></p>
<p></p>
<p>
<span>6.&nbsp;LINSERT&nbsp;key&nbsp;BEFORE|AFTER&nbsp;pivot&nbsp;value&nbsp;</span></p>
<p>
<span>在列表的元素前或者后插入元素</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;linsert&nbsp;list2&nbsp;before&nbsp;&quot;bar&quot;&nbsp;&quot;yes&quot;</span></p>
<p>
<span>(integer)&nbsp;3</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;lrange&nbsp;list2&nbsp;0&nbsp;5</span></p>
<p>
<span>1)&nbsp;&quot;yes&quot;</span></p>
<p>
<span>2)&nbsp;&quot;bar&quot;</span></p>
<p>
<span>3)&nbsp;&quot;foo&quot;127.0.0.1:6379&gt;&nbsp;linsert&nbsp;list2&nbsp;after&nbsp;&quot;bar&quot;&nbsp;&quot;yes&quot;</span></p>
<p>
<span>(integer)&nbsp;4</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;lrange&nbsp;list2&nbsp;0&nbsp;5</span></p>
<p>
<span>1)&nbsp;&quot;yes&quot;</span></p>
<p>
<span>2)&nbsp;&quot;bar&quot;</span></p>
<p>
<span>3)&nbsp;&quot;yes&quot;</span></p>
<p>
<span>4)&nbsp;&quot;foo&quot;</span></p>
<p></p>
<p>
<span>7.&nbsp;LPOP&nbsp;key&nbsp;</span></p>
<p>
<span>移出并获取列表的第一个元素</span></p>
<p>
<span>8.&nbsp;RPOP&nbsp;key&nbsp;</span></p>
<p>
<span>移除并获取列表最后一个元素</span></p>
<p></p>
<p>
<span>9.&nbsp;LPUSH&nbsp;key&nbsp;value1&nbsp;[value2]&nbsp;</span></p>
<p>
<span>将一个或多个值插入到列表头部</span></p>
<p>
<span>10.&nbsp;LPUSHX&nbsp;key&nbsp;value&nbsp;</span></p>
<p>
<span>将一个或多个值插入到已存在的列表头部</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;lpushx&nbsp;list3&nbsp;vv</span></p>
<p>
<span>(integer)&nbsp;0</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;lpushx&nbsp;list2&nbsp;vv</span></p>
<p>
<span>(integer)&nbsp;5</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;lrange&nbsp;list2&nbsp;0&nbsp;5</span></p>
<p>
<span>1)&nbsp;&quot;vv&quot;</span></p>
<p>
<span>2)&nbsp;&quot;yes&quot;</span></p>
<p>
<span>3)&nbsp;&quot;bar&quot;</span></p>
<p>
<span>4)&nbsp;&quot;yes&quot;</span></p>
<p>
<span>5)&nbsp;&quot;foo&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;</span></p>
<p></p>
<p>
<span>11.&nbsp;LREM&nbsp;key&nbsp;count&nbsp;value&nbsp;</span></p>
<p>
<span>移除列表元素</span></p>
<p>
<span>Lrem&nbsp;根据参数&nbsp;COUNT&nbsp;的值，移除列表中与参数&nbsp;VALUE&nbsp;相等的元素。</span></p>
<p>
<span>COUNT&nbsp;的值可以是以下几种：</span></p>
<p>
<span>count&nbsp;&gt;&nbsp;0&nbsp;:&nbsp;从表头开始向表尾搜索，移除与&nbsp;VALUE&nbsp;相等的元素，数量为&nbsp;COUNT&nbsp;。</span></p>
<p>
<span>count&nbsp;&lt;&nbsp;0&nbsp;:&nbsp;从表尾开始向表头搜索，移除与&nbsp;VALUE&nbsp;相等的元素，数量为&nbsp;COUNT&nbsp;的绝对值。</span></p>
<p>
<span>count&nbsp;=&nbsp;0&nbsp;:&nbsp;移除表中所有与&nbsp;VALUE&nbsp;相等的值。</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;lrem&nbsp;list2&nbsp;0&nbsp;yes</span></p>
<p>
<span>(integer)&nbsp;2</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;lrange&nbsp;list2&nbsp;0&nbsp;5</span></p>
<p>
<span>1)&nbsp;&quot;vv&quot;</span></p>
<p>
<span>2)&nbsp;&quot;bar&quot;</span></p>
<p></p>
<p>
<span>12.&nbsp;LSET&nbsp;key&nbsp;index&nbsp;value&nbsp;</span></p>
<p>
<span>通过索引设置列表元素的值</span></p>
<p></p>
<p>
<span>13.&nbsp;LTRIM&nbsp;key&nbsp;start&nbsp;stop&nbsp;</span></p>
<p>
<span>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</span></p>
<p>
<span>下标&nbsp;0&nbsp;表示列表的第一个元素，以&nbsp;1&nbsp;表示列表的第二个元素，以此类推。&nbsp;</span></p>
<p>
<span>你也可以使用负数下标，以&nbsp;-1&nbsp;表示列表的最后一个元素，&nbsp;-2&nbsp;表示列表的倒数第二个元素，以此类推。</span></p>
<p></p>
<p>
<span>14.&nbsp;RPOPLPUSH&nbsp;source&nbsp;destination&nbsp;</span></p>
<p>
<span>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</span></p>
<p></p>
<p>
<span>15.&nbsp;RPUSH&nbsp;key&nbsp;value1&nbsp;[value2]&nbsp;</span></p>
<p>
<span>在列表中添加一个或多个值</span></p>
<p>
<span>16.RPUSHX&nbsp;key&nbsp;value&nbsp;</span></p>
<p>
<span>为已存在的列表添加值</span></p>
<p></p>
<p>
<span>要明确一点，redis中的lists在底层实现上并不是数组，而是链表。</span></p>
<p>
<span>也就是说对于一个具有上百万个元素的lists来说，在头部和尾部插入一个新元素，其时间复杂度是常数级别的，比如用LPUSH在10个元素的lists头部插入新元素，和在上千万元素的lists头部插入新元素的速度应该是相同的。</span></p>
<p>
<span>链表型lists的元素定位会比较慢，而数组型lists的元素定位就会快得多。</span></p>
<p></p>
<p>
<span>lists的应用相当广泛，随便举几个例子：</span></p>
<p></p>
<p>
<span>我们可以利用lists来实现一个消息队列，而且可以确保先后顺序，不必像MySQL那样还需要通过ORDER&nbsp;BY来进行排序。</span></p>
<p>
<span>利用LRANGE还可以很方便的实现分页的功能。</span></p>
<p>
<span>在博客系统中，每片博文的评论也可以存入一个单独的list中。</span></p>
<p></p>
<p>
<span>----------------------------------------</span></p>
<p></p>
<p>
<span style="font-weight: bold">redis数据结构&nbsp;-&nbsp;set</span></p>
<p>
<span>Redis的Set是string类型的无序集合。</span></p>
<p>
<span>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</span></p>
<p>
<span>集合内元素的唯一性，第二次插入相同的元素将被忽略。</span></p>
<p>
<span>集合中最大的成员数为&nbsp;2</span>
<span style="vertical-align: super">32&nbsp;-&nbsp;1</span>
<span>&nbsp;(4294967295,&nbsp;每个集合可存储40多亿个成员)。</span></p>
<p></p>
<p>
<span>测试用例：</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;SADD&nbsp;setarr&nbsp;v1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//向集合添加一个或多个成员</span></p>
<p>
<span>(integer)&nbsp;1</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;SADD&nbsp;setarr&nbsp;v2&nbsp;v3</span></p>
<p>
<span>(integer)&nbsp;2</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;smembers&nbsp;setarr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//返回集合中的所有成员</span></p>
<p>
<span>1)&nbsp;&quot;v2&quot;</span></p>
<p>
<span>2)&nbsp;&quot;v3&quot;</span></p>
<p>
<span>3)&nbsp;&quot;v1&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;scard&nbsp;setarr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取集合的成员数</span></p>
<p>
<span>(integer)&nbsp;3</span></p>
<p></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;sadd&nbsp;setarr1&nbsp;v1&nbsp;vv1&nbsp;k1</span></p>
<p>
<span>(integer)&nbsp;3</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;sdiff&nbsp;setarr&nbsp;setarr1&nbsp;&nbsp;&nbsp;//返回给定所有集合的差集&nbsp;返回setarr中不同于setarr1的</span></p>
<p>
<span>1)&nbsp;&quot;v2&quot;</span></p>
<p>
<span>2)&nbsp;&quot;v3&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;sdiff&nbsp;setarr1&nbsp;setarr&nbsp;&nbsp;&nbsp;//返回setarr1中不同于setarr的</span></p>
<p>
<span>1)&nbsp;&quot;vv1&quot;</span></p>
<p>
<span>2)&nbsp;&quot;k1&quot;</span></p>
<p></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;sdiffstore&nbsp;cha&nbsp;setarr&nbsp;setarr1&nbsp;&nbsp;//返回给定所有集合的差集并存储在&nbsp;cha或者cha1&nbsp;中</span></p>
<p>
<span>(integer)&nbsp;2</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;smembers&nbsp;cha</span></p>
<p>
<span>1)&nbsp;&quot;v2&quot;</span></p>
<p>
<span>2)&nbsp;&quot;v3&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;sdiffstore&nbsp;cha1&nbsp;setarr1&nbsp;setarr</span></p>
<p>
<span>(integer)&nbsp;2</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;smembers&nbsp;cha1</span></p>
<p>
<span>1)&nbsp;&quot;vv1&quot;</span></p>
<p>
<span>2)&nbsp;&quot;k1&quot;</span></p>
<p></p>
<p>
<span>//判断&nbsp;member&nbsp;元素是否是集合&nbsp;key&nbsp;的成员</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;sismember&nbsp;setarr&nbsp;vv1&nbsp;&nbsp;&nbsp;&nbsp;//不是setarr成员，返回0</span></p>
<p>
<span>(integer)&nbsp;0</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;sismember&nbsp;setarr&nbsp;v1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//是setarr成员的，返回1</span></p>
<p>
<span>(integer)&nbsp;1</span></p>
<p></p>
<p>
<span>//SMOVE&nbsp;source&nbsp;destination&nbsp;member&nbsp;将&nbsp;member&nbsp;元素从&nbsp;source&nbsp;集合移动到&nbsp;destination&nbsp;集合</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;smembers&nbsp;setarr</span></p>
<p>
<span>1)&nbsp;&quot;v2&quot;</span></p>
<p>
<span>2)&nbsp;&quot;v3&quot;</span></p>
<p>
<span>3)&nbsp;&quot;v1&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;smembers&nbsp;setarr1</span></p>
<p>
<span>1)&nbsp;&quot;k1&quot;</span></p>
<p>
<span>2)&nbsp;&quot;vv1&quot;</span></p>
<p>
<span>3)&nbsp;&quot;v1&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;smove&nbsp;setarr1&nbsp;setarr&nbsp;vv1</span></p>
<p>
<span>(integer)&nbsp;1</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;smembers&nbsp;setarr</span></p>
<p>
<span>1)&nbsp;&quot;vv1&quot;</span></p>
<p>
<span>2)&nbsp;&quot;v2&quot;</span></p>
<p>
<span>3)&nbsp;&quot;v3&quot;</span></p>
<p>
<span>4)&nbsp;&quot;v1&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;smembers&nbsp;setarr1</span></p>
<p>
<span>1)&nbsp;&quot;k1&quot;</span></p>
<p>
<span>2)&nbsp;&quot;v1&quot;</span></p>
<p></p>
<p>
<span>//SPOP&nbsp;key&nbsp;&nbsp;移除并返回集合中的一个随机元素</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;smembers&nbsp;setarr</span></p>
<p>
<span>1)&nbsp;&quot;vv1&quot;</span></p>
<p>
<span>2)&nbsp;&quot;v2&quot;</span></p>
<p>
<span>3)&nbsp;&quot;v3&quot;</span></p>
<p>
<span>4)&nbsp;&quot;v1&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;spop&nbsp;setarr</span></p>
<p>
<span>&quot;v2&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;smembers&nbsp;setarr</span></p>
<p>
<span>1)&nbsp;&quot;vv1&quot;</span></p>
<p>
<span>2)&nbsp;&quot;v3&quot;</span></p>
<p>
<span>3)&nbsp;&quot;v1&quot;</span></p>
<p></p>
<p>
<span>//SRANDMEMBER&nbsp;key&nbsp;[count]&nbsp;返回集合中一个或多个随机数</span></p>
<p>
<span>//只提供集合&nbsp;key&nbsp;参数时，返回一个元素；&nbsp;如果提供了&nbsp;count&nbsp;参数，那么返回一个数组；如果集合为空，返回空数组。</span></p>
<p>
<span>//该操作和&nbsp;SPOP&nbsp;相似，但&nbsp;SPOP&nbsp;将随机元素从集合中移除并返回，而&nbsp;Srandmember&nbsp;则仅仅返回随机元素，而不对集合进行任何改动。</span></p>
<p>
<span>参数count的解释：</span></p>
<p>
<span>如果&nbsp;count&nbsp;为正数，且小于集合基数，那么命令返回一个包含&nbsp;count&nbsp;个元素的数组，</span>
<span style="color: #800000">数组中的元素各不相同</span>
<span style="color: #000000">。如果&nbsp;count&nbsp;大于等于集合基数，那么返回整个集合。</span></p>
<p>
<span>如果&nbsp;count&nbsp;为负数，那么命令返回一个数组，</span>
<span style="color: #800000">数组中的元素可能会重复出现多次</span>
<span style="color: #000000">，而数组的长度为&nbsp;count&nbsp;的绝对值。</span></p>
<p></p>
<p>
<span>//SREM&nbsp;key&nbsp;member1&nbsp;[member2]&nbsp;移除集合中一个或多个成员</span></p>
<p></p>
<p>
<span>//SUNION&nbsp;key1&nbsp;[key2]&nbsp;返回所有给定集合的并集</span></p>
<p></p>
<p>
<span>//SUNIONSTORE&nbsp;destination&nbsp;key1&nbsp;[key2]&nbsp;所有给定集合的并集存储在&nbsp;destination&nbsp;集合中</span></p>
<p></p>
<p>
<span>//SSCAN&nbsp;key&nbsp;cursor&nbsp;[MATCH&nbsp;pattern]&nbsp;[COUNT&nbsp;count]&nbsp;迭代集合中的元素</span></p>
<p></p>
<p>
<span>//SSCAN&nbsp;key&nbsp;cursor&nbsp;[MATCH&nbsp;pattern]&nbsp;[COUNT&nbsp;count]&nbsp;迭代集合中的元素</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;sscan&nbsp;setarr&nbsp;0&nbsp;match&nbsp;&quot;v*&quot;</span></p>
<p>
<span>1)&nbsp;&quot;0&quot;</span></p>
<p>
<span>2)&nbsp;1)&nbsp;&quot;vv1&quot;</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;2)&nbsp;&quot;v3&quot;</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;3)&nbsp;&quot;v1&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;</span></p>
<p>
<span>ps:SCAN&nbsp;命令是一个基于游标的迭代器。这意味着命令每次被调用都需要使用上一次这个调用返回的游标作为该次调用的游标参数，以此来延续之前的迭代过程</span></p>
<p>
<span>当&nbsp;SCAN&nbsp;命令的游标参数被设置为&nbsp;0&nbsp;时，&nbsp;服务器将开始一次新的迭代，&nbsp;而当服务器向用户返回值为&nbsp;0&nbsp;的游标时，&nbsp;表示迭代已结束。</span></p>
<p></p>
<p>
<span>运用场景：</span></p>
<p>
<span>QQ有一个社交功能叫做&quot;好友标签&quot;，大家可以给你的好友贴标签，比如&quot;大美女&quot;、&quot;土豪&quot;、&quot;欧巴&quot;等等，这时就可以使用redis的集合来实现，把每一个用户的标签都存储在一个集合之中。</span></p>
<p></p>
<p>
<span>----------------------------------------</span></p>
<p>
<span style="font-weight: bold">redis数据结构&nbsp;-&nbsp;zset</span></p>
<p>
<span>Redis&nbsp;zset&nbsp;和&nbsp;set&nbsp;一样也是string类型元素的集合,且不允许重复的成员。</span></p>
<p>
<span>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</span></p>
<p>
<span>zset的成员是唯一的,但分数(score)却可以重复。</span></p>
<p>
<span>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。&nbsp;集合中最大的成员数为&nbsp;2</span>
<span style="vertical-align: super">32&nbsp;-&nbsp;1</span>
<span>&nbsp;(4294967295,&nbsp;每个集合可存储40多亿个成员)。</span></p>
<p></p>
<p>
<span>实例：</span></p>
<p>
<span>向有序集合添加一个或多个成员，或者更新已存在成员的分数。</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;zadd&nbsp;myset&nbsp;1&nbsp;hello&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p>
<span>(integer)&nbsp;1</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;zadd&nbsp;myset&nbsp;3&nbsp;foo</span></p>
<p>
<span>(integer)&nbsp;1</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;zadd&nbsp;myset&nbsp;2&nbsp;bar</span></p>
<p>
<span>(integer)&nbsp;1</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;zrange&nbsp;myset&nbsp;0&nbsp;-1</span></p>
<p>
<span>1)&nbsp;&quot;hello&quot;</span></p>
<p>
<span>2)&nbsp;&quot;bar&quot;</span></p>
<p>
<span>3)&nbsp;&quot;foo&quot;</span></p>
<p>
<span>排列顺序是按照zadd添加的顺序来的。</span></p>
<p></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;zcard&nbsp;myset&nbsp;&nbsp;&nbsp;&nbsp;//获取有序集合的成员数量</span></p>
<p>
<span>(integer)&nbsp;3</span></p>
<p></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;zadd&nbsp;myset&nbsp;1.5&nbsp;tt</span></p>
<p>
<span>(integer)&nbsp;1</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;zcount&nbsp;myset&nbsp;1&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;//Zcount&nbsp;命令用于计算有序集合中指定分数区间的成员数量。</span></p>
<p>
<span>(integer)&nbsp;4</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;zrange&nbsp;myset&nbsp;0&nbsp;-1</span></p>
<p>
<span>1)&nbsp;&quot;hello&quot;</span></p>
<p>
<span>2)&nbsp;&quot;tt&quot;</span></p>
<p>
<span>3)&nbsp;&quot;bar&quot;</span></p>
<p>
<span>4)&nbsp;&quot;foo&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;</span></p>
<p></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;zincrby&nbsp;myset&nbsp;2&nbsp;tt&nbsp;&nbsp;//Zincrby&nbsp;命令对有序集合中指定成员的分数加上增量&nbsp;increment</span></p>
<p>
<span>&quot;3.5&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;zrange&nbsp;myset&nbsp;0&nbsp;-1</span></p>
<p>
<span>1)&nbsp;&quot;hello&quot;</span></p>
<p>
<span>2)&nbsp;&quot;bar&quot;</span></p>
<p>
<span>3)&nbsp;&quot;foo&quot;</span></p>
<p>
<span>4)&nbsp;&quot;tt&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;</span></p>
<p></p>
<p>
<span>ZINTERSTORE&nbsp;destination&nbsp;numkeys&nbsp;key&nbsp;[key&nbsp;...]&nbsp;</span></p>
<p>
<span>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合&nbsp;key&nbsp;中</span></p>
<p>
<img src="img_29884.bmp"></img></p>
<p></p>
<p>
<span>Zlexcount&nbsp;命令在计算有序集合中指定字典区间内成员数量。</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;zrange&nbsp;myzset&nbsp;0&nbsp;-1</span></p>
<p>
<span>1)&nbsp;&quot;a&quot;</span></p>
<p>
<span>2)&nbsp;&quot;b&quot;</span></p>
<p>
<span>3)&nbsp;&quot;c&quot;</span></p>
<p>
<span>4)&nbsp;&quot;d&quot;</span></p>
<p>
<span>5)&nbsp;&quot;e&quot;</span></p>
<p>
<span>6)&nbsp;&quot;f&quot;</span></p>
<p>
<span>7)&nbsp;&quot;g&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;ZLEXCOUNT&nbsp;myzset&nbsp;[b&nbsp;[f&nbsp;&nbsp;&nbsp;//b，c，d，e，f&nbsp;共5个</span></p>
<p>
<span>(integer)&nbsp;5</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;ZLEXCOUNT&nbsp;myzset&nbsp;-&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;//计算全部的成员数量</span></p>
<p>
<span>(integer)&nbsp;7</span></p>
<p></p>
<p>
<span>//ZRANGE&nbsp;key&nbsp;start&nbsp;stop&nbsp;[WITHSCORES]&nbsp;</span></p>
<p>
<span>通过索引区间返回有序集合成指定区间内的成员</span></p>
<p>
<span>//ZRANGEBYLEX&nbsp;key&nbsp;min&nbsp;max&nbsp;[LIMIT&nbsp;offset&nbsp;count]&nbsp;</span></p>
<p>
<span>通过字典区间返回有序集合的成员</span></p>
<p>
<span>下标参数&nbsp;start&nbsp;和&nbsp;stop&nbsp;都以&nbsp;0&nbsp;为底，也就是说，以&nbsp;0&nbsp;表示有序集第一个成员，以&nbsp;1&nbsp;表示有序集第二个成员，以此类推。</span></p>
<p></p>
<p>
<span>//Zrangebylex&nbsp;通过字典区间返回有序集合的成员。</span></p>
<p>
<span>redis&nbsp;127.0.0.1:6379&gt;&nbsp;ZADD&nbsp;myzset&nbsp;0&nbsp;a&nbsp;0&nbsp;b&nbsp;0&nbsp;c&nbsp;0&nbsp;d&nbsp;0&nbsp;e&nbsp;0&nbsp;f&nbsp;0&nbsp;g</span></p>
<p>
<span>(integer)&nbsp;7</span></p>
<p>
<span>redis&nbsp;127.0.0.1:6379&gt;&nbsp;ZRANGEBYLEX&nbsp;myzset&nbsp;-&nbsp;[c&nbsp;&nbsp;//从开始到c元素，一共有哪些键值</span></p>
<p>
<span>1)&nbsp;&quot;a&quot;</span></p>
<p>
<span>2)&nbsp;&quot;b&quot;</span></p>
<p>
<span>3)&nbsp;&quot;c&quot;</span></p>
<p>
<span>redis&nbsp;127.0.0.1:6379&gt;&nbsp;ZRANGEBYLEX&nbsp;myzset&nbsp;-&nbsp;(c&nbsp;&nbsp;//不包括c</span></p>
<p>
<span>1)&nbsp;&quot;a&quot;</span></p>
<p>
<span>2)&nbsp;&quot;b&quot;</span></p>
<p>
<span>redis&nbsp;127.0.0.1:6379&gt;&nbsp;ZRANGEBYLEX&nbsp;myzset&nbsp;[aaa&nbsp;(g&nbsp;&nbsp;&nbsp;//包括aaa，但是不包括g</span></p>
<p>
<span>1)&nbsp;&quot;b&quot;</span></p>
<p>
<span>2)&nbsp;&quot;c&quot;</span></p>
<p>
<span>3)&nbsp;&quot;d&quot;</span></p>
<p>
<span>4)&nbsp;&quot;e&quot;</span></p>
<p>
<span>5)&nbsp;&quot;f&quot;</span></p>
<p></p>
<p>
<span>ZRANGEBYSCORE&nbsp;key&nbsp;min&nbsp;max&nbsp;[WITHSCORES]&nbsp;[LIMIT]&nbsp;</span></p>
<p>
<span>通过分数返回有序集合指定区间内的成员</span></p>
<p></p>
<p>
<span>ZRANK&nbsp;key&nbsp;member&nbsp;</span></p>
<p>
<span>返回有序集合中指定成员的索引</span></p>
<p></p>
<p>
<span>ZREM&nbsp;key&nbsp;member&nbsp;[member&nbsp;...]&nbsp;</span></p>
<p>
<span>移除有序集合中的一个或多个成员</span></p>
<p></p>
<p>
<span>ZREMRANGEBYLEX&nbsp;key&nbsp;min&nbsp;max&nbsp;</span></p>
<p>
<span>移除有序集合中给定的字典区间的所有成员</span></p>
<p></p>
<p>
<span>ZREMRANGEBYRANK&nbsp;key&nbsp;start&nbsp;stop&nbsp;</span></p>
<p>
<span>移除有序集合中给定的排名区间的所有成员</span></p>
<p></p>
<p>
<span>ZREMRANGEBYSCORE&nbsp;key&nbsp;min&nbsp;max&nbsp;</span></p>
<p>
<span>移除有序集合中给定的分数区间的所有成员</span></p>
<p></p>
<p>
<span>ZREVRANGE&nbsp;key&nbsp;start&nbsp;stop&nbsp;[WITHSCORES]&nbsp;</span></p>
<p>
<span>返回有序集中指定区间内的成员，通过索引，分数从高到底</span></p>
<p></p>
<p>
<span>ZREVRANGEBYSCORE&nbsp;key&nbsp;max&nbsp;min&nbsp;[WITHSCORES]&nbsp;</span></p>
<p>
<span>返回有序集中指定分数区间内的成员，分数从高到低排序</span></p>
<p></p>
<p>
<span>ZREVRANK&nbsp;key&nbsp;member&nbsp;</span></p>
<p>
<span>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</span></p>
<p></p>
<p>
<span>ZSCORE&nbsp;key&nbsp;member&nbsp;</span></p>
<p>
<span>返回有序集中，成员的分数值</span></p>
<p></p>
<p>
<span>ZUNIONSTORE&nbsp;destination&nbsp;numkeys&nbsp;key&nbsp;[key&nbsp;...]&nbsp;</span></p>
<p>
<span>计算给定的一个或多个有序集的并集，并存储在新的&nbsp;key&nbsp;中</span></p>
<p></p>
<p>
<span>ZSCAN&nbsp;key&nbsp;cursor&nbsp;[MATCH&nbsp;pattern]&nbsp;[COUNT&nbsp;count]&nbsp;</span></p>
<p>
<span>迭代有序集合中的元素（包括元素成员和元素分值）</span></p>
<p></p>
<p></p>
<ul id="ID_PictFileNames" style="display: none">
<li fn="img_26010.bmp"></li>
<li fn="img_1425.bmp"></li>
<li fn="img_10845.bmp"></li>
<li fn="img_8307.bmp"></li>
<li fn="img_29884.bmp"></li></ul></dd>

<dt>Redis发布订阅</dt>
<dd>
<p>
<span style="font-family: 宋体; font-size: 11pt; color: #000000">消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</span></p>
<p>
<img src="img_7997.bmp"></img></p>
<p>
<img src="img_3600.bmp"></img></p>
<p>
<span>在最后一个客户端发布一条redisRadio的消息，会返回有多少个客户端已经接受到。</span></p>
<p>
<img src="img_10173.bmp"></img></p>
<p></p>
<p>
<span>Pubsub&nbsp;命令用于查看订阅与发布系统状态，它由数个不同格式的子命令组成。</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;pubsub&nbsp;channels&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回订阅的频道。是由活跃频道组成的列表。</span></p>
<p>
<span>1)&nbsp;&quot;redisChat&quot;</span></p>
<p>
<span>2)&nbsp;&quot;redisRadio&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;unsubscribe&nbsp;&nbsp;退订不成功？</span></p>
<p></p>
<p></p>
<p></p>
<ul id="ID_PictFileNames" style="display: none">
<li fn="img_7997.bmp"></li>
<li fn="img_3600.bmp"></li>
<li fn="img_10173.bmp"></li></ul></dd>

<dt>Redis事务</dt>
<dd>
<p>
<span style="font-family: 宋体; font-size: 11pt; color: #000000">众所周知，事务是指&quot;一个完整的动作，要么全部执行，要么什么也不做&quot;。</span></p>
<p></p>
<p>
<span>Redis重要特征：</span></p>
<p>
<span>1.事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</span></p>
<p>
<span>2.事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</span></p>
<p></p>
<p>
<span>三个阶段：</span></p>
<p>
<span>开始事务</span></p>
<p>
<span>命令入队</span></p>
<p>
<span>执行事务</span></p>
<p></p>
<p>
<span>实例：</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;multi&nbsp;&nbsp;&nbsp;&nbsp;//标记一个事务块的开始</span></p>
<p>
<span>OK</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;SET&nbsp;book-name&nbsp;&quot;Mastering&nbsp;C++&nbsp;in&nbsp;21&nbsp;days&quot;</span></p>
<p>
<span>QUEUED</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;get&nbsp;book-name</span></p>
<p>
<span>QUEUED</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;SADD&nbsp;tag&nbsp;&quot;C++&quot;&nbsp;&quot;Programming&quot;&nbsp;&quot;Mastering&nbsp;Series&quot;</span></p>
<p>
<span>QUEUED</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;smembers&nbsp;tag</span></p>
<p>
<span>QUEUED</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;exec&nbsp;&nbsp;&nbsp;&nbsp;//执行所有的事务块命令</span></p>
<p>
<span>1)&nbsp;OK</span></p>
<p>
<span>2)&nbsp;&quot;Mastering&nbsp;C++&nbsp;in&nbsp;21&nbsp;days&quot;</span></p>
<p>
<span>3)&nbsp;(integer)&nbsp;3</span></p>
<p>
<span>4)&nbsp;1)&nbsp;&quot;Mastering&nbsp;Series&quot;</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;2)&nbsp;&quot;Programming&quot;</span></p>
<p>
<span>&nbsp;&nbsp;&nbsp;3)&nbsp;&quot;C++&quot;</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;</span></p>
<p></p>
<p>
<span>//DISCARD&nbsp;取消事务，放弃执行事务块内的所有命令。</span></p>
<p>
<span>在multi开始事务以后，执行该操作，会放弃之前所有命令</span></p>
<p></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;watch&nbsp;name&nbsp;&nbsp;&nbsp;&nbsp;//监视name</span></p>
<p>
<span>OK</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;multi</span></p>
<p>
<span>OK</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;get&nbsp;name</span></p>
<p>
<span>QUEUED</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;get&nbsp;peter-name&nbsp;&nbsp;&nbsp;//这个期间把name值改了</span></p>
<p>
<span>QUEUED</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;exec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//执行失败</span></p>
<p>
<span>(nil)</span></p>
<p></p>
<p>
<span>UNWATCH&nbsp;</span></p>
<p>
<span>取消&nbsp;WATCH&nbsp;命令对所有&nbsp;key&nbsp;的监视。</span></p>
<p>
<span>----------------------------------------</span></p>
<p>
<span>对于事务的执行来说，如果redis开启了AOF持久化的话，那么一旦事务被成功执行，事务中的命令就会通过write命令一次性写到磁盘中去，如果在向磁盘中写的过程中恰好出现断电、硬件故障等问题，那么就可能出现只有部分命令进行了AOF持久化，这时AOF文件就会出现不完整的情况，这时，我们可以使用redis-check-aof工具来修复这一问题，这个工具会将AOF文件中不完整的信息移除，确保AOF文件完整可用。</span></p>
<p>
<span>----------------------------------------</span></p>
<p>
<span>有关事务的错误处理：</span></p>
<p>
<span>1.&nbsp;调用EXEC之前的错误</span></p>
<p>
<span>&quot;调用EXEC之前的错误&quot;，有可能是由于语法有误导致的，也可能时由于内存不足导致的。</span></p>
<p>
<span>只要出现某个命令无法成功写入缓冲队列的情况，redis都会进行记录，在客户端调用EXEC时，redis会拒绝执行这一事务。（这时2.6.5版本之后的策略。在2.6.5之前的版本中，redis会忽略那些入队失败的命令，只执行那些入队成功的命令）。</span></p>
<p>
<img src="img_6363.bmp"></img></p>
<p>
<span>2.&nbsp;调用EXEC之后的错误</span></p>
<p>
<span>而对于&quot;调用EXEC之后的错误&quot;，redis则采取了完全不同的策略，即redis不会理睬这些错误，而是继续向下执行事务中的其他命令。这是因为，对于应用层面的错误，并不是redis自身需要考虑和处理的问题，所以一个事务中如果某一条命令执行失败，并不会影响接下来的其他命令的执行。</span></p>
<p>
<img src="img_8800.bmp"></img></p>
<p>
<span>----------------------------------------</span></p>
<p></p>
<p>
<span>指令&quot;WATCH&quot;，很好用的指令，它可以帮我们实现类似于&quot;乐观锁&quot;的效果，即CAS（check&nbsp;and&nbsp;set）。</span></p>
<p>
<span>WATCH本身的作用是&quot;监视key是否被改动过&quot;，而且支持同时监视多个key，只要还没真正触发事务，WATCH都会尽职尽责的监视。</span></p>
<p>
<span>一旦发现某个key被修改了，在执行EXEC时就会返回nil，表示事务无法触发。</span></p>
<p>
<img src="img_1179.bmp"></img></p>
<p></p>
<ul id="ID_PictFileNames" style="display: none">
<li fn="img_6363.bmp"></li>
<li fn="img_8800.bmp"></li>
<li fn="img_1179.bmp"></li></ul></dd>

<dt>Redis脚本</dt>
<dd>
<p>
<span style="font-family: 宋体; font-size: 11pt; color: #000000">实例：</span></p>
<p>
<img src="img_17698.bmp"></img></p>
<p></p>
<p>
<span>参数说明：</span></p>
<p>
<span>script：&nbsp;参数是一段&nbsp;Lua&nbsp;5.1&nbsp;脚本程序。脚本不必(也不应该)定义为一个&nbsp;Lua&nbsp;函数。</span></p>
<p>
<span>numkeys：&nbsp;用于指定键名参数的个数。</span></p>
<p>
<span>key&nbsp;[key&nbsp;...]：&nbsp;表示在脚本中所用到的那些&nbsp;Redis&nbsp;键(key)，这些键名参数可以在&nbsp;Lua&nbsp;中通过全局变量&nbsp;KEYS&nbsp;数组，用&nbsp;1&nbsp;为基址的形式访问(&nbsp;KEYS[1]&nbsp;，&nbsp;KEYS[2]&nbsp;，以此类推)。</span></p>
<p>
<span>arg&nbsp;[arg&nbsp;...]：&nbsp;附加参数，在&nbsp;Lua&nbsp;中通过全局变量&nbsp;ARGV&nbsp;数组访问，访问的形式和&nbsp;KEYS&nbsp;变量类似(&nbsp;ARGV[1]&nbsp;、&nbsp;ARGV[2]&nbsp;，诸如此类)。</span></p>
<p></p>
<p>
<span>----------------------------------------</span></p>
<p></p>
<p>
<span>&nbsp;Evalsha&nbsp;命令根据给定的&nbsp;sha1&nbsp;校验码，执行缓存在服务器中的脚本。</span></p>
<p></p>
<p>
<span>----------------------------------------</span></p>
<p></p>
<p>
<span>Script&nbsp;Exists&nbsp;命令用于校验指定的脚本是否已经被保存在缓存当中。</span></p>
<p>
<span>返回值&nbsp;一个列表，包含&nbsp;0&nbsp;和&nbsp;1&nbsp;，0表示脚本不存在于缓存，1表示脚本已经在缓存里面了。</span></p>
<p>
<img src="img_25306.bmp"></img></p>
<p></p>
<p>
<span>SCRIPT&nbsp;LOAD&nbsp;script&nbsp;</span></p>
<p>
<span>将脚本&nbsp;script&nbsp;添加到脚本缓存中，但并不立即执行这个脚本。</span></p>
<p></p>
<p>
<span>SCRIPT&nbsp;FLUSH&nbsp;</span></p>
<p>
<span>从脚本缓存中移除所有脚本。</span></p>
<p></p>
<p>
<span>----------------------------------------</span></p>
<p></p>
<p>
<span>Script&nbsp;kill&nbsp;命令用于杀死当前正在运行的&nbsp;Lua&nbsp;脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。</span></p>
<p>
<span>这个命令主要用于终止运行时间过长的脚本，比如一个因为&nbsp;BUG&nbsp;而发生无限循环的脚本。</span></p>
<p>
<span>SCRIPT&nbsp;KILL&nbsp;执行之后，当前正在运行的脚本会被杀死，执行这个脚本的客户端会从&nbsp;EVAL&nbsp;命令的阻塞当中退出，并收到一个错误作为返回值。</span></p>
<p></p>
<ul id="ID_PictFileNames" style="display: none">
<li fn="img_17698.bmp"></li>
<li fn="img_25306.bmp"></li></ul></dd>

<dt>Redis连接命令</dt>
<dd>......</dd>

<dt>Redis服务器命令</dt>
<dd>
<p>
<span style="font-family: 宋体; font-size: 11pt; color: #000000">主要用于管理redis服务。</span></p>
<p></p>
<p></p></dd>

<dt>Redis数据备份与恢复</dt>
<dd>
<p>
<span style="font-family: 宋体; font-size: 11pt; color: #000000">SAVE&nbsp;命令用于创建当前数据库的备份。</span></p>
<p>
<span>备份的redis数据会放在安装目录的dump.rdb文件中。</span></p>
<p></p>
<p>
<span>获取redis的安装目录</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;config&nbsp;get&nbsp;dir</span></p>
<p>
<span>1)&nbsp;&quot;dir&quot;</span></p>
<p>
<span>2)&nbsp;&quot;/home/yanli/Downloads/redis-2.8.15/src&quot;</span></p>
<p></p>
<p>
<span>获取redis的备份文件dump.rdb，没有备份之前</span></p>
<p>
<span>[yanli@FirstPro&nbsp;src]%HTML_CONTENT%nbsp;ls&nbsp;-al&nbsp;|&nbsp;grep&nbsp;dump.rdb</span></p>
<p>
<span>-rw-rw-r--.&nbsp;1&nbsp;yanli&nbsp;yanli&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;606&nbsp;Jan&nbsp;25&nbsp;18:06&nbsp;dump.rdb</span></p>
<p></p>
<p>
<span>执行redis的备份命令</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;save</span></p>
<p>
<span>OK</span></p>
<p></p>
<p>
<span>查看dump.rdb&nbsp;的生成时间</span></p>
<p>
<span>[yanli@FirstPro&nbsp;src]%HTML_CONTENT%nbsp;ls&nbsp;-al&nbsp;|&nbsp;grep&nbsp;dump.rdb</span></p>
<p>
<span>-rw-rw-r--.&nbsp;1&nbsp;yanli&nbsp;yanli&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;606&nbsp;Jan&nbsp;26&nbsp;10:19&nbsp;dump.rdb</span></p>
<p>
<span>确实是当下执行的时间</span></p>
<p></p>
<p>
<span>----------------------------------------</span></p>
<p></p>
<p>
<span style="font-weight: bold">恢复数据</span></p>
<p>
<span>***如果需要恢复数据，只需将备份文件&nbsp;(dump.rdb)&nbsp;移动到&nbsp;redis&nbsp;安装目录并启动服务即可。</span></p>
<p>
<span>1.把当前的dump.rdb&nbsp;文件拷贝到其他地方备份</span></p>
<p>
<span>2.清空当前数据库做测试</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;flushdb</span></p>
<p>
<span>OK</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;keys&nbsp;*</span></p>
<p>
<span>(empty&nbsp;list&nbsp;or&nbsp;set)</span></p>
<p>
<span>3.把备份好的dump.rdb文件拷贝到安装目录</span></p>
<p>
<span>[yanli@FirstPro&nbsp;src]%HTML_CONTENT%nbsp;rm&nbsp;dump.rdb</span></p>
<p>
<span>[yanli@FirstPro&nbsp;src]%HTML_CONTENT%nbsp;ls&nbsp;-al&nbsp;|&nbsp;grep&nbsp;dump.rdb</span></p>
<p>
<span>[yanli@FirstPro&nbsp;src]%HTML_CONTENT%nbsp;cp&nbsp;/home/yanli/dump.rdb&nbsp;./dump.rdb</span></p>
<p>
<span>[yanli@FirstPro&nbsp;src]%HTML_CONTENT%nbsp;ls&nbsp;-al&nbsp;|&nbsp;grep&nbsp;dump.rdb</span></p>
<p>
<span>-rw-rw-r--.&nbsp;1&nbsp;yanli&nbsp;yanli&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;40&nbsp;Jan&nbsp;26&nbsp;10:42&nbsp;dump.rdb</span></p>
<p>
<span>4.启动redis</span></p>
<p>
<span>5.启动客户端进行查看</span></p>
<p>
<span>[yanli@FirstPro&nbsp;src]%HTML_CONTENT%nbsp;./redis-cli</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;keys&nbsp;*</span></p>
<p>
<span>1)&nbsp;&quot;name&quot;</span></p>
<p>
<span>2)&nbsp;&quot;age&quot;</span></p>
<p>
<span>说明已经恢复数据了。</span></p>
<p>
<span>----------------------------------------</span></p>
<p></p>
<p>
<span style="font-weight: bold">Bgsave&nbsp;后台执行备份</span></p>
<p>
<span>创建&nbsp;redis&nbsp;备份文件也可以使用命令&nbsp;BGSAVE，该命令在后台执行。</span></p>
<p>
<span>实例</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;BGSAVE</span></p>
<p>
<span>Background&nbsp;saving&nbsp;started</span></p>
<p></p>
<p></p>
<p></p></dd>

<dt>Redis配置 - 安全</dt>
<dd>
<p>
<span style="font-family: 宋体; font-size: 11pt; color: #000000">当你的redis-server处于一个不太可信的网络环境中时，相信你会用上这个功能。</span></p>
<p>
<span>由于redis性能非常高，所以每秒钟可以完成多达15万次的密码尝试，所以你最好设置一个足够复杂的密码，否则很容易被黑客破解。</span></p>
<p>
<span>通过&nbsp;redis&nbsp;的配置文件设置密码参数，这样客户端连接到&nbsp;redis&nbsp;服务就需要密码验证，这样可以让你的&nbsp;redis&nbsp;服务更安全。</span></p>
<p></p>
<p>
<span>通过命令查看启动redis时，是否需要密码验证</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;config&nbsp;get&nbsp;requirepass</span></p>
<p>
<span>1)&nbsp;&quot;requirepass&quot;</span></p>
<p>
<span>2)&nbsp;&quot;&quot;</span></p>
<p>
<span>默认情况下&nbsp;requirepass&nbsp;参数是空的，这就意味着你无需通过密码验证就可以连接到&nbsp;redis&nbsp;服务。</span></p>
<p></p>
<p>
<span>设置改参数：</span></p>
<p>
<img src="img_31209.bmp"></img></p>
<p></p>
<p>
<span>退出redis，再次启动客户端，也必须认证。</span></p>
<p></p>
<p>
<span>设置了密码，每次进入客户端，执行redis命令的时候，都需要进行密码认证。</span></p>
<p></p>
<p>
<span>----------------------------------------</span></p>
<p></p>
<p>
<span>redis允许我们对redis指令进行更名，比如将一些比较危险的命令改个名字，避免被误执行。</span></p>
<p>
<span>rename-command&nbsp;CONFIG&nbsp;b840fc02d524045429941cc15f59e41cb7be6c89</span></p>
<p>
<span>甚至可以禁用掉CONFIG命令，那就是把CONFIG的名字改成一个空字符串</span></p>
<p>
<span>rename-command&nbsp;CONFIG&nbsp;&quot;&quot;</span></p>
<p>
<span>注意：如果你使用AOF方式进行数据持久化，或者需要与从redis进行通信，那么更改指令的名字可能会引起一些问题。</span></p>
<p></p>
<ul id="ID_PictFileNames" style="display: none">
<li fn="img_31209.bmp"></li></ul></dd>

<dt>Redis性能测试</dt>
<dd>
<p>
<span style="font-family: 宋体; font-size: 11pt; color: #000000">性能测试是通过同时执行多个命令实现的。</span></p>
<p>
<span>命令：</span></p>
<p>
<span>redis-benchmark&nbsp;[option]&nbsp;[option&nbsp;value]</span></p>
<p></p>
<p>
<span>参数详解如下：</span></p>
<p>
<img src="img_9252.bmp"></img></p>
<p></p>
<p>
<span>实例：</span></p>
<p>
<span>在redis安装目录下，执行：</span></p>
<p>
<span>redis-benchmark&nbsp;-n&nbsp;10000</span></p>
<p>
<span>redis-benchmark&nbsp;-h&nbsp;127.0.0.1&nbsp;-p&nbsp;6379&nbsp;-t&nbsp;set,lpush&nbsp;-n&nbsp;10000&nbsp;-q</span></p>
<p></p>
<ul id="ID_PictFileNames" style="display: none">
<li fn="img_9252.bmp"></li></ul></dd>

<dt>Redis客户端连接</dt>
<dd>
<p>
<span style="font-family: 宋体; font-size: 11pt; color: #000000">Redis&nbsp;通过监听一个&nbsp;TCP&nbsp;端口或者&nbsp;Unix&nbsp;socket&nbsp;的方式来接收来自客户端的连接，当一个连接建立后，Redis&nbsp;内部会进行以下一些操作：</span></p>
<p>
<span>首先，客户端&nbsp;socket&nbsp;会被设置为非阻塞模式，因为&nbsp;Redis&nbsp;在网络事件处理上采用的是非阻塞多路复用模型。</span></p>
<p>
<span>然后为这个&nbsp;socket&nbsp;设置&nbsp;TCP_NODELAY&nbsp;属性，禁用&nbsp;Nagle&nbsp;算法。</span></p>
<p>
<span>然后创建一个可读的文件事件用于监听这个客户端&nbsp;socket&nbsp;的数据发送。</span></p>
<p></p>
<p>
<span>----------------------------------------</span></p>
<p></p>
<p>
<span style="font-weight: bold">最大连接数</span></p>
<p></p>
<p>
<span>在&nbsp;Redis2.4&nbsp;中，最大连接数是被直接硬编码在代码里面的，而在2.6版本中这个值变成可配置的。</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;config&nbsp;get&nbsp;maxclients</span></p>
<p>
<span>1)&nbsp;&quot;maxclients&quot;</span></p>
<p>
<span>2)&nbsp;&quot;4064&quot;</span></p>
<p></p>
<p>
<span>设置最大连接数：在服务启动时设置最大连接数为&nbsp;100000</span></p>
<p>
<span>redis-server&nbsp;--maxclients&nbsp;100000</span></p>
<p></p>
<p>
<span>客户端命令</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;client&nbsp;list&nbsp;&nbsp;&nbsp;//返回连接到&nbsp;redis&nbsp;服务的客户端列表</span></p>
<p>
<span>id=6&nbsp;addr=127.0.0.1:57399&nbsp;fd=6&nbsp;name=&nbsp;age=11317&nbsp;idle=0&nbsp;flags=N&nbsp;db=0&nbsp;sub=0&nbsp;psub=0&nbsp;multi=-1&nbsp;qbuf=0&nbsp;qbuf-free=32768&nbsp;obl=0&nbsp;oll=0&nbsp;omem=0&nbsp;events=r&nbsp;cmd=client</span></p>
<p></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;client&nbsp;setname&nbsp;yanliRedis&nbsp;&nbsp;&nbsp;//设置当前连接的名称</span></p>
<p>
<span>OK</span></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;client&nbsp;getname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取通过&nbsp;CLIENT&nbsp;SETNAME&nbsp;命令设置的服务名称</span></p>
<p>
<span>&quot;yanliRedis&quot;</span></p>
<p></p>
<p>
<span>127.0.0.1:6379&gt;&nbsp;client&nbsp;pause&nbsp;10000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//挂起客户端连接，指定挂起的时间以毫秒计。timeout设置错误会报错？</span></p>
<p>
<span>(error)&nbsp;ERR&nbsp;Syntax&nbsp;error,&nbsp;try&nbsp;CLIENT&nbsp;(LIST&nbsp;|&nbsp;KILL&nbsp;ip:port&nbsp;|&nbsp;GETNAME&nbsp;|&nbsp;SETNAME&nbsp;connection-name)</span></p>
<p></p>
<p>
<span>CLIENT&nbsp;KILL&nbsp;关闭客户端连接</span></p>
<p>
<img src="img_2785.bmp"></img></p>
<p></p>
<ul id="ID_PictFileNames" style="display: none">
<li fn="img_2785.bmp"></li></ul></dd>

<dt>Redis管道技术</dt>
<dd>
<p>
<span style="font-family: 宋体; font-size: 11pt; color: #000000">Redis&nbsp;管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。</span></p>
<p></p></dd>

<dt>PHP使用Redis</dt>
<dd>
<p>
<span style="font-family: 宋体; font-size: 11pt; color: #000000">在已经安装了redis服务，保证能正常使用php的前提下，安装redis驱动。</span></p>
<p>
<span>----------------------------------------</span></p>
<p>
<span>php安装完成，发现没有安装phpize。它是用来安装php扩展模块的，安装redis需要用到phpize。</span></p>
<p>
<span>操作步骤：</span></p>
<p>
<span>1.phpize&nbsp;是属于&nbsp;php-devel&nbsp;中的东西，主要是设定&nbsp;php&nbsp;外挂模块的一些设定&nbsp;。</span></p>
<p>
<span>所以安装&nbsp;php-devel&nbsp;相关套件就会有&nbsp;phpize&nbsp;可以使用&nbsp;(档案预设存放于&nbsp;/usr/bin/phpize&nbsp;)&nbsp;</span></p>
<p></p>
<p>
<span>[root@FirstPro&nbsp;/]#&nbsp;yum&nbsp;install&nbsp;php-devel</span></p>
<p></p>
<p>
<span>2.&nbsp;安装完，查看命令所在位置</span></p>
<p></p>
<p>
<span>[root@FirstPro&nbsp;bin]#&nbsp;which&nbsp;phpize</span></p>
<p>
<span>/usr/bin/phpize</span></p>
<p></p>
<p>
<span>记住这个路径，之后会用到。</span></p>
<p>
<span>----------------------------------------</span></p>
<p>
<span style="font-weight: bold">安装redis</span></p>
<p></p>
<p>
<span>PHP&nbsp;redis&nbsp;驱动下载地址(这是一个PHP的第三方的扩展模块，但是获得了PHP官方的授权)</span></p>
<p>
<a href="https://github.com/nicolasff/phpredis">https://github.com/nicolasff/phpredis</a></p>
<p>
<span>下载源码或zip压缩包</span></p>
<p>
<a href="https://github.com/phpredis/phpredis/archive/develop.zip">https://github.com/phpredis/phpredis/archive/develop.zip</a></p>
<p></p>
<p>
<span>[root@FirstPro&nbsp;michael]#&nbsp;git&nbsp;clone&nbsp;</span>
<a href="https://github.com/nicolasff/phpredis">https://github.com/nicolasff/phpredis</a>
<span style="font-family: 宋体; font-size: 11pt; text-decoration: underline; color: #000000">&nbsp;&nbsp;&nbsp;&nbsp;//获取phpredis</span></p>
<p>
<span>Cloning&nbsp;into&nbsp;&apos;phpredis&apos;...</span></p>
<p>
<span>remote:&nbsp;Counting&nbsp;objects:&nbsp;6629,&nbsp;done.</span></p>
<p>
<span>remote:&nbsp;Compressing&nbsp;objects:&nbsp;100%&nbsp;(13/13),&nbsp;done.</span></p>
<p>
<span>remote:&nbsp;Total&nbsp;6629&nbsp;(delta&nbsp;0),&nbsp;reused&nbsp;0&nbsp;(delta&nbsp;0),&nbsp;pack-reused&nbsp;6616</span></p>
<p>
<span>Receiving&nbsp;objects:&nbsp;100%&nbsp;(6629/6629),&nbsp;3.42&nbsp;MiB&nbsp;|&nbsp;179&nbsp;KiB/s,&nbsp;done.</span></p>
<p>
<span>Resolving&nbsp;deltas:&nbsp;100%&nbsp;(4401/4401),&nbsp;done.</span></p>
<p>
<span>[root@FirstPro&nbsp;michael]#&nbsp;ls&nbsp;-l</span></p>
<p>
<span>drwxr-xr-x.&nbsp;6&nbsp;root&nbsp;&nbsp;root&nbsp;&nbsp;4096&nbsp;Jan&nbsp;27&nbsp;10:06&nbsp;phpredis</span></p>
<p></p>
<p>
<span>[root@FirstPro&nbsp;michael]#&nbsp;cd&nbsp;phpredis/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//进入phpredis目录</span></p>
<p>
<span>[root@FirstPro&nbsp;phpredis]#&nbsp;whereis&nbsp;phpize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//查看phpize位置</span></p>
<p>
<span>phpize:&nbsp;/usr/bin/phpize&nbsp;/usr/share/man/man1/phpize.1.gz</span></p>
<p>
<span>[root@FirstPro&nbsp;phpredis]#&nbsp;ls</span></p>
<p>
<span>arrays.markdown&nbsp;&nbsp;&nbsp;&nbsp;crc16.h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;php_redis.h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis_commands.c</span></p>
<p>
<span>bybits.php&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CREDITS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;README.markdown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis_commands.h</span></p>
<p>
<span>cluster_library.c&nbsp;&nbsp;debian&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis_array.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis_session.c</span></p>
<p>
<span>cluster_library.h&nbsp;&nbsp;debian.control&nbsp;&nbsp;&nbsp;&nbsp;redis_array.h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis_session.h</span></p>
<p>
<span>cluster.markdown&nbsp;&nbsp;&nbsp;library.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis_array_impl.c&nbsp;&nbsp;rpm</span></p>
<p>
<span>common.h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;library.h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis_array_impl.h&nbsp;&nbsp;serialize.list</span></p>
<p>
<span>config.m4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mkdeb-apache2.sh&nbsp;&nbsp;redis.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tests</span></p>
<p>
<span>config.w32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mkdeb.sh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis_cluster.c</span></p>
<p>
<span>COPYING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;package.xml&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis_cluster.h</span></p>
<p>
<span>[root@FirstPro&nbsp;phpredis]#&nbsp;/usr/bin/phpize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//执行</span></p>
<p>
<span>Configuring&nbsp;for:</span></p>
<p>
<span>PHP&nbsp;Api&nbsp;Version:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20090626</span></p>
<p>
<span>Zend&nbsp;Module&nbsp;Api&nbsp;No:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20090626</span></p>
<p>
<span>Zend&nbsp;Extension&nbsp;Api&nbsp;No:&nbsp;&nbsp;&nbsp;220090626</span></p>
<p>
<span>[root@FirstPro&nbsp;phpredis]#&nbsp;ls&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//运行完毕，phpredis出现configure</span></p>
<p>
<span>acinclude.m4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;config.sub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Makefile.global&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis_cluster.c</span></p>
<p>
<span>aclocal.m4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;configure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;missing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis_cluster.h</span></p>
<p>
<span>arrays.markdown&nbsp;&nbsp;&nbsp;&nbsp;configure.in&nbsp;&nbsp;&nbsp;&nbsp;mkdeb-apache2.sh&nbsp;&nbsp;&nbsp;&nbsp;redis_commands.c</span></p>
<p>
<span>autom4te.cache&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;config.w32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mkdeb.sh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis_commands.h</span></p>
<p>
<span>build&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COPYING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mkinstalldirs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis_session.c</span></p>
<p>
<span>bybits.php&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;crc16.h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;package.xml&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis_session.h</span></p>
<p>
<span>cluster_library.c&nbsp;&nbsp;CREDITS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;php_redis.h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rpm</span></p>
<p>
<span>cluster_library.h&nbsp;&nbsp;debian&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;README.markdown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run-tests.php</span></p>
<p>
<span>cluster.markdown&nbsp;&nbsp;&nbsp;debian.control&nbsp;&nbsp;redis_array.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serialize.list</span></p>
<p>
<span>common.h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;install-sh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis_array.h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tests</span></p>
<p>
<span>config.guess&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;library.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis_array_impl.c</span></p>
<p>
<span>config.h.in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;library.h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis_array_impl.h</span></p>
<p>
<span>config.m4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ltmain.sh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis.c</span></p>
<p>
<span>[root@FirstPro&nbsp;phpredis]#&nbsp;whereis&nbsp;php-config&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//命令行脚本，用于获取所安装的php配置的信息</span></p>
<p>
<span>php-config:&nbsp;/usr/bin/php-config&nbsp;/usr/share/man/man1/php-config.1.gz</span></p>
<p>
<span>[root@FirstPro&nbsp;phpredis]#&nbsp;./configure&nbsp;--with-php-config=/usr/bin/php-config</span></p>
<p>
<span>checking&nbsp;for&nbsp;grep&nbsp;that&nbsp;handles&nbsp;long&nbsp;lines&nbsp;and&nbsp;-e...&nbsp;/bin/grep</span></p>
<p>
<span>checking&nbsp;for&nbsp;egrep...&nbsp;/bin/grep&nbsp;-E</span></p>
<p>
<span>checking&nbsp;for&nbsp;a&nbsp;sed&nbsp;that&nbsp;does&nbsp;not&nbsp;truncate&nbsp;output...&nbsp;/bin/sed</span></p>
<p>
<span>checking&nbsp;for&nbsp;cc...&nbsp;cc</span></p>
<p>
<span>checking&nbsp;for&nbsp;C&nbsp;compiler&nbsp;default&nbsp;output&nbsp;file&nbsp;name...&nbsp;a.out</span></p>
<p>
<span>checking&nbsp;whether&nbsp;the&nbsp;C&nbsp;compiler&nbsp;works...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;whether&nbsp;we&nbsp;are&nbsp;cross&nbsp;compiling...&nbsp;no</span></p>
<p>
<span>checking&nbsp;for&nbsp;suffix&nbsp;of&nbsp;executables...&nbsp;</span></p>
<p>
<span>checking&nbsp;for&nbsp;suffix&nbsp;of&nbsp;object&nbsp;files...&nbsp;o</span></p>
<p>
<span>checking&nbsp;whether&nbsp;we&nbsp;are&nbsp;using&nbsp;the&nbsp;GNU&nbsp;C&nbsp;compiler...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;whether&nbsp;cc&nbsp;accepts&nbsp;-g...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;for&nbsp;cc&nbsp;option&nbsp;to&nbsp;accept&nbsp;ISO&nbsp;C89...&nbsp;none&nbsp;needed</span></p>
<p>
<span>checking&nbsp;how&nbsp;to&nbsp;run&nbsp;the&nbsp;C&nbsp;preprocessor...&nbsp;cc&nbsp;-E</span></p>
<p>
<span>checking&nbsp;for&nbsp;icc...&nbsp;no</span></p>
<p>
<span>checking&nbsp;for&nbsp;suncc...&nbsp;no</span></p>
<p>
<span>checking&nbsp;whether&nbsp;cc&nbsp;understands&nbsp;-c&nbsp;and&nbsp;-o&nbsp;together...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;for&nbsp;system&nbsp;library&nbsp;directory...&nbsp;lib</span></p>
<p>
<span>checking&nbsp;if&nbsp;compiler&nbsp;supports&nbsp;-R...&nbsp;no</span></p>
<p>
<span>checking&nbsp;if&nbsp;compiler&nbsp;supports&nbsp;-Wl,-rpath,...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;build&nbsp;system&nbsp;type...&nbsp;x86_64-unknown-linux-gnu</span></p>
<p>
<span>checking&nbsp;host&nbsp;system&nbsp;type...&nbsp;x86_64-unknown-linux-gnu</span></p>
<p>
<span>checking&nbsp;target&nbsp;system&nbsp;type...&nbsp;x86_64-unknown-linux-gnu</span></p>
<p>
<span>checking&nbsp;for&nbsp;PHP&nbsp;prefix...&nbsp;/usr</span></p>
<p>
<span>checking&nbsp;for&nbsp;PHP&nbsp;includes...&nbsp;-I/usr/include/php&nbsp;-I/usr/include/php/main&nbsp;-I/usr/include/php/TSRM&nbsp;-I/usr/include/php/Zend&nbsp;-I/usr/include/php/ext&nbsp;-I/usr/include/php/ext/date/lib</span></p>
<p>
<span>checking&nbsp;for&nbsp;PHP&nbsp;extension&nbsp;directory...&nbsp;/usr/lib64/php/modules</span></p>
<p>
<span>checking&nbsp;for&nbsp;PHP&nbsp;installed&nbsp;headers&nbsp;prefix...&nbsp;/usr/include/php</span></p>
<p>
<span>checking&nbsp;if&nbsp;debug&nbsp;is&nbsp;enabled...&nbsp;no</span></p>
<p>
<span>checking&nbsp;if&nbsp;zts&nbsp;is&nbsp;enabled...&nbsp;no</span></p>
<p>
<span>checking&nbsp;for&nbsp;re2c...&nbsp;no</span></p>
<p>
<span>configure:&nbsp;WARNING:&nbsp;You&nbsp;will&nbsp;need&nbsp;re2c&nbsp;0.13.4&nbsp;or&nbsp;later&nbsp;if&nbsp;you&nbsp;want&nbsp;to&nbsp;regenerate&nbsp;PHP&nbsp;parsers.</span></p>
<p>
<span>checking&nbsp;for&nbsp;gawk...&nbsp;gawk</span></p>
<p>
<span>checking&nbsp;whether&nbsp;to&nbsp;enable&nbsp;redis&nbsp;support...&nbsp;yes,&nbsp;shared</span></p>
<p>
<span>checking&nbsp;whether&nbsp;to&nbsp;enable&nbsp;sessions...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;whether&nbsp;to&nbsp;enable&nbsp;igbinary&nbsp;serializer&nbsp;support...&nbsp;no</span></p>
<p>
<span>checking&nbsp;for&nbsp;redis&nbsp;igbinary&nbsp;support...&nbsp;disabled</span></p>
<p>
<span>checking&nbsp;for&nbsp;a&nbsp;sed&nbsp;that&nbsp;does&nbsp;not&nbsp;truncate&nbsp;output...&nbsp;(cached)&nbsp;/bin/sed</span></p>
<p>
<span>checking&nbsp;for&nbsp;fgrep...&nbsp;/bin/grep&nbsp;-F</span></p>
<p>
<span>checking&nbsp;for&nbsp;ld&nbsp;used&nbsp;by&nbsp;cc...&nbsp;/usr/bin/ld</span></p>
<p>
<span>checking&nbsp;if&nbsp;the&nbsp;linker&nbsp;(/usr/bin/ld)&nbsp;is&nbsp;GNU&nbsp;ld...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;for&nbsp;BSD-&nbsp;or&nbsp;MS-compatible&nbsp;name&nbsp;lister&nbsp;(nm)...&nbsp;/usr/bin/nm&nbsp;-B</span></p>
<p>
<span>checking&nbsp;the&nbsp;name&nbsp;lister&nbsp;(/usr/bin/nm&nbsp;-B)&nbsp;interface...&nbsp;BSD&nbsp;nm</span></p>
<p>
<span>checking&nbsp;whether&nbsp;ln&nbsp;-s&nbsp;works...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;the&nbsp;maximum&nbsp;length&nbsp;of&nbsp;command&nbsp;line&nbsp;arguments...&nbsp;1966080</span></p>
<p>
<span>checking&nbsp;whether&nbsp;the&nbsp;shell&nbsp;understands&nbsp;some&nbsp;XSI&nbsp;constructs...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;whether&nbsp;the&nbsp;shell&nbsp;understands&nbsp;&quot;+=&quot;...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;for&nbsp;/usr/bin/ld&nbsp;option&nbsp;to&nbsp;reload&nbsp;object&nbsp;files...&nbsp;-r</span></p>
<p>
<span>checking&nbsp;for&nbsp;objdump...&nbsp;objdump</span></p>
<p>
<span>checking&nbsp;how&nbsp;to&nbsp;recognize&nbsp;dependent&nbsp;libraries...&nbsp;pass_all</span></p>
<p>
<span>checking&nbsp;for&nbsp;ar...&nbsp;ar</span></p>
<p>
<span>checking&nbsp;for&nbsp;strip...&nbsp;strip</span></p>
<p>
<span>checking&nbsp;for&nbsp;ranlib...&nbsp;ranlib</span></p>
<p>
<span>checking&nbsp;command&nbsp;to&nbsp;parse&nbsp;/usr/bin/nm&nbsp;-B&nbsp;output&nbsp;from&nbsp;cc&nbsp;object...&nbsp;ok</span></p>
<p>
<span>checking&nbsp;for&nbsp;ANSI&nbsp;C&nbsp;header&nbsp;files...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;for&nbsp;sys/types.h...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;for&nbsp;sys/stat.h...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;for&nbsp;stdlib.h...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;for&nbsp;string.h...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;for&nbsp;memory.h...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;for&nbsp;strings.h...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;for&nbsp;inttypes.h...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;for&nbsp;stdint.h...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;for&nbsp;unistd.h...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;for&nbsp;dlfcn.h...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;for&nbsp;objdir...&nbsp;.libs</span></p>
<p>
<span>checking&nbsp;if&nbsp;cc&nbsp;supports&nbsp;-fno-rtti&nbsp;-fno-exceptions...&nbsp;no</span></p>
<p>
<span>checking&nbsp;for&nbsp;cc&nbsp;option&nbsp;to&nbsp;produce&nbsp;PIC...&nbsp;-fPIC&nbsp;-DPIC</span></p>
<p>
<span>checking&nbsp;if&nbsp;cc&nbsp;PIC&nbsp;flag&nbsp;-fPIC&nbsp;-DPIC&nbsp;works...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;if&nbsp;cc&nbsp;static&nbsp;flag&nbsp;-static&nbsp;works...&nbsp;no</span></p>
<p>
<span>checking&nbsp;if&nbsp;cc&nbsp;supports&nbsp;-c&nbsp;-o&nbsp;file.o...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;if&nbsp;cc&nbsp;supports&nbsp;-c&nbsp;-o&nbsp;file.o...&nbsp;(cached)&nbsp;yes</span></p>
<p>
<span>checking&nbsp;whether&nbsp;the&nbsp;cc&nbsp;linker&nbsp;(/usr/bin/ld&nbsp;-m&nbsp;elf_x86_64)&nbsp;supports&nbsp;shared&nbsp;libraries...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;whether&nbsp;-lc&nbsp;should&nbsp;be&nbsp;explicitly&nbsp;linked&nbsp;in...&nbsp;no</span></p>
<p>
<span>checking&nbsp;dynamic&nbsp;linker&nbsp;characteristics...&nbsp;GNU/Linux&nbsp;ld.so</span></p>
<p>
<span>checking&nbsp;how&nbsp;to&nbsp;hardcode&nbsp;library&nbsp;paths&nbsp;into&nbsp;programs...&nbsp;immediate</span></p>
<p>
<span>checking&nbsp;whether&nbsp;stripping&nbsp;libraries&nbsp;is&nbsp;possible...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;if&nbsp;libtool&nbsp;supports&nbsp;shared&nbsp;libraries...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;whether&nbsp;to&nbsp;build&nbsp;shared&nbsp;libraries...&nbsp;yes</span></p>
<p>
<span>checking&nbsp;whether&nbsp;to&nbsp;build&nbsp;static&nbsp;libraries...&nbsp;no</span></p>
<p>
<span>configure:&nbsp;creating&nbsp;./config.status</span></p>
<p>
<span>config.status:&nbsp;creating&nbsp;config.h</span></p>
<p>
<span>config.status:&nbsp;executing&nbsp;libtool&nbsp;commands</span></p>
<p>
<span>[root@FirstPro&nbsp;phpredis]#&nbsp;make&nbsp;&amp;&amp;&nbsp;make&nbsp;install&nbsp;&nbsp;&nbsp;//安装</span></p>
<p>
<img src="img_7906.bmp"></img></p>
<p>
<span>安装完毕。</span></p>
<p></p>
<p>
<span>----------------------------------------</span></p>
<p></p>
<p>
<span style="font-weight: bold">修改php.ini文件，添加redis扩展</span></p>
<p></p>
<p>
<img src="img_24494.bmp"></img></p>
<p>
<span>在php.ini&nbsp;中添加内容：</span></p>
<p>
<span>[Redis]</span></p>
<p>
<span>extension_dir&nbsp;=&nbsp;&quot;/usr/lib64/php/modules/&quot;&nbsp;&nbsp;&nbsp;//安装共享扩展目录</span></p>
<p>
<span>extension=redis.so</span></p>
<p></p>
<p>
<span>配置完成后重启php-fpm&nbsp;或&nbsp;apache。查看phpinfo信息，就能看到redis扩展。</span></p>
<p></p>
<p>
<span>----------------------------------------</span></p>
<p>
<span style="font-weight: bold">php连接Redis</span></p>
<p>
<span>保证以下几点：</span></p>
<p>
<span>1.防火墙要放行redis启用的端口号，默认是6379。</span></p>
<p>
<span>2.redis.conf&nbsp;要bind&nbsp;redis监听的ip地址。</span></p>
<p>
<span>3.服务器上要启动redis服务。</span></p>
<p>
<span>4.关闭seLinux。</span></p>
<p></p>
<p>
<span>实例：</span></p>
<p>
<span>&lt;?php</span></p>
<p>
<span>$redis&nbsp;=&nbsp;new&nbsp;Redis();</span></p>
<p>
<span>var_dump($redis);</span></p>
<p>
<span>$redis-&gt;connect(&apos;127.0.0.1&apos;,&nbsp;6379);</span></p>
<p>
<span>$redis-&gt;auth(&quot;pass&quot;);</span></p>
<p>
<span>echo&nbsp;$redis-&gt;ping();</span></p>
<p>
<span>$redis-&gt;set(&apos;sex&apos;,&nbsp;&apos;1&apos;);</span></p>
<p>
<span>echo&nbsp;$redis-&gt;get(&apos;sex&apos;);</span></p>
<p>
<span>服务器上可以执行该php文件，但是web页面访问报错：</span></p>
<p></p>
<p>
<img src="img_6999.bmp"></img></p>
<p>
<span>原因：seLinux阻碍了httpd的网络连接。</span></p>
<p>
<span>----------------------------------------</span></p>
<p>
<span style="font-weight: bold">seLinux</span></p>
<p>
<span>全称&nbsp;Security&nbsp;Enhanced&nbsp;Linux&nbsp;(安全强化&nbsp;Linux)</span></p>
<p>
<span>1.&nbsp;明确的指明某个进程可以访问哪些资源(文件、网络端口等)。</span></p>
<p>
<span>2.&nbsp;增强系统抵御&nbsp;0-Day&nbsp;攻击(利用尚未公开的漏洞实现的攻击行为)的能力。它不是网络防火墙或&nbsp;ACL&nbsp;的替代品，在用途上也不重复。</span></p>
<p>
<span>3.&nbsp;系统上的&nbsp;Apache&nbsp;被发现存在一个漏洞，使得某远程用户可以访问系统上的敏感文件(比如&nbsp;/etc/passwd&nbsp;来获得系统已存在用户)，而修复该安全漏洞的&nbsp;Apache&nbsp;更新补丁尚未释出。此时&nbsp;SELinux&nbsp;可以起到弥补该漏洞的缓和方案。</span></p>
<p></p>
<p>
<span>获取seLinux状态&nbsp;getenforce。</span></p>
<p>
<span>可能返回结果有三种：Enforcing、Permissive&nbsp;和&nbsp;Disabled。Disabled&nbsp;代表&nbsp;SELinux&nbsp;被禁用，Permissive&nbsp;代表仅记录安全警告但不阻止可疑行为，Enforcing&nbsp;代表记录警告且阻止可疑行为。</span></p>
<p></p>
<p>
<span>改变&nbsp;SELinux&nbsp;运行状态</span></p>
<p>
<span>setenforce&nbsp;[&nbsp;Enforcing&nbsp;|&nbsp;Permissive&nbsp;|&nbsp;1&nbsp;|&nbsp;0&nbsp;]</span></p>
<p>
<span>若是在&nbsp;setenforce&nbsp;0&nbsp;之后服务或者程序依然无法运行，那么就可以肯定不是&nbsp;SELinux&nbsp;导致的。</span></p>
<p></p>
<p>
<span>永久变更系统&nbsp;SELinux&nbsp;运行环境，可以通过更改配置文件&nbsp;/etc/sysconfig/selinux&nbsp;实现。</span></p>
<p></p>
<ul id="ID_PictFileNames" style="display: none">
<li fn="img_7906.bmp"></li>
<li fn="img_24494.bmp"></li>
<li fn="img_6999.bmp"></li></ul></dd>

<dt>聊聊redis持久化</dt>
<dd>
<p>
<span style="font-family: 宋体; font-size: 11pt; color: #000000">redis提供了两种持久化的方式，分别是RDB（Redis&nbsp;DataBase）和AOF（Append&nbsp;Only&nbsp;File）。</span></p>
<p>
<span>如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。</span></p>
<p></p>
<p>
<span>一&nbsp;RDB</span></p>
<p>
<span>就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；</span></p>
<p></p>
<p>
<span>对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。</span></p>
<p></p>
<p>
<span>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。</span></p>
<p></p>
<p>
<span>如果你对数据的完整性非常敏感，即使你每5分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失。所以，redis还提供了另一种持久化方式，那就是AOF。</span></p>
<p></p>
<p>
<span>二&nbsp;AOF</span></p>
<p>
<span>Append&nbsp;Only&nbsp;File，即只允许追加不允许改写的文件。</span></p>
<p>
<span>将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。</span></p>
<p></p>
<p>
<span>AOF设置</span></p>
<p>
<span>通过配置redis.conf中的appendonly&nbsp;yes就可以打开AOF功能。</span></p>
<p></p>
<p>
<span>AOF持久化策略</span></p>
<p>
<span>默认的AOF持久化策略是</span>
<span style="font-weight: bold">每秒钟fsync一次</span>
<span>（fsync是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。</span></p>
<p></p>
<p>
<span>日志修复</span></p>
<p>
<span>如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了redis-check-aof工具，可以用来进行日志修复。</span></p>
<p></p>
<p>
<span>重写机制</span></p>
<p>
<span>AOF采用了追加方式，如果不做任何处理的话，AOF文件会变得越来越大，为此，redis提供了AOF文件重写（rewrite）机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。</span></p>
<p>
<span>举个例子，假如我们调用了100次INCR指令，在AOF文件中就要存储100条指令，但这明显是很低效的，完全可以把这100条指令合并成一条SET指令，这就是重写机制的原理。</span></p>
<p>
<span>在进行AOF重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响AOF文件的可用性。</span></p>
<p></p>
<p>
<span>缺点：</span></p>
<p>
<span>同样数据规模的情况下，AOF文件要比RDB文件的体积大。而且，AOF方式的恢复速度也要慢于RDB方式。</span></p>
<p></p>
<p>
<span>修复出错的AOF文件</span></p>
<p>
<span>如果你直接执行BGREWRITEAOF命令，那么redis会生成一个全新的AOF文件，其中便包括了可以恢复现有数据的最少的命令集。</span></p>
<p>
<span>AOF文件出现了被写坏的情况，也不必过分担忧，redis并不会贸然加载这个有问题的AOF文件，而是报错退出。这时可以通过以下步骤来修复出错的文件：</span></p>
<p>
<span>1.&nbsp;备份被写坏的AOF文件</span></p>
<p>
<span>2.&nbsp;运行redis-check-aof&nbsp;-fix进行修复</span></p>
<p>
<span>3.&nbsp;用diff&nbsp;-u来看下两个文件的差异，确认问题点</span></p>
<p>
<span>3.&nbsp;重启redis，加载修复后的AOF文件</span></p>
<p></p></dd>

<dt>聊聊主从</dt>
<dd>
<p>
<span style="font-family: 宋体; font-size: 11pt; color: #000000">一&nbsp;用法</span></p>
<p>
<span>主从结构，一是为了纯粹的冗余备份，二是为了提升读性能，比如很消耗性能的SORT就可以由从服务器来承担。</span></p>
<p></p>
<p>
<span>主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。</span></p>
<p></p>
<p>
<span>在主从架构中，从服务器通常被设置为只读模式，这样可以避免从服务器的数据被误修改。但是从服务器仍然可以接受CONFIG等指令，所以还是不应该将从服务器直接暴露到不安全的网络环境中。如果必须如此，那可以考虑给重要指令进行重命名，来避免命令被外人误执行。</span></p>
<p></p>
<p>
<span>二&nbsp;同步原理</span></p>
<p></p>
<p>
<img src="img_11415.bmp"></img></p>
<p></p>
<p>
<span>即使有多个从服务器同时发来SYNC指令，主服务器也只会执行一次BGSAVE，然后把持久化好的RDB文件发给多个下游。</span></p>
<p>
<span>在redis2.8版本之前，如果从服务器与主服务器因某些原因断开连接的话，都会进行一次主从之间的全量的数据同步；</span></p>
<p>
<span>而在2.8版本之后，redis支持了效率更高的增量同步策略，这大大降低了连接断开的恢复成本。</span></p>
<p>
<span>从服务器在与主服务器出现网络瞬断之后，从服务器会尝试再次与主服务器连接，一旦连接成功，从服务器就会把&quot;希望同步的主服务器ID&quot;和&quot;希望请求的数据的偏移位置（replication&nbsp;offset）&quot;发送出去。主服务器接收到这样的同步请求后，首先会验证主服务器ID是否和自己的ID匹配，其次会检查&quot;请求的偏移位置&quot;是否存在于自己的缓冲区中，如果两者都满足的话，主服务器就会向从服务器发送增量内容。</span></p>
<p></p>
<p></p>
<ul id="ID_PictFileNames" style="display: none">
<li fn="img_11415.bmp"></li></ul></dd>

<dt>Redis配置</dt>
<dd>
<p>
<span style="font-family: 宋体; font-size: 11pt; font-weight: bold; color: #000000">一&nbsp;简介</span></p>
<p>
<span>在启动redis-server时指定应该加载的配置文件</span></p>
<p>
<span>%HTML_CONTENT%nbsp;./redis-server&nbsp;/path/to/redis.conf</span></p>
<p></p>
<p>
<span>redis官方提供的redis.conf文件，足有700+行，其中100多行为有效配置行，另外的600多行为注释说明。</span></p>
<p></p>
<p>
<span>配置文件明确规定的度量单位;</span></p>
<p>
<span>#&nbsp;1k&nbsp;=&gt;&nbsp;1000&nbsp;bytes</span></p>
<p>
<span>#&nbsp;1kb&nbsp;=&gt;&nbsp;1024&nbsp;bytes</span></p>
<p>
<span>#&nbsp;1m&nbsp;=&gt;&nbsp;1000000&nbsp;bytes</span></p>
<p>
<span>#&nbsp;1mb&nbsp;=&gt;&nbsp;1024*1024&nbsp;bytes</span></p>
<p>
<span>#&nbsp;1g&nbsp;=&gt;&nbsp;1000000000&nbsp;bytes</span></p>
<p>
<span>#&nbsp;1gb&nbsp;=&gt;&nbsp;1024*1024*1024&nbsp;bytes</span></p>
<p>
<span>由此也说明，redis只支持bytes，不支持bit单位。</span></p>
<p></p>
<p>
<span>redis支持&quot;主配置文件中引入外部配置文件&quot;</span></p>
<p>
<span>include&nbsp;/path/to/other.conf</span></p>
<p></p>
<p>
<span>redis配置文件被分成了几大块区域，它们分别是：</span></p>
<p></p>
<p>
<span>通用（general）</span></p>
<p>
<span>快照（snapshotting）</span></p>
<p>
<span>复制（replication）</span></p>
<p>
<span>安全（security）</span></p>
<p>
<span>限制（limits)</span></p>
<p>
<span>追加模式（append&nbsp;only&nbsp;mode)</span></p>
<p>
<span>LUA脚本（lua&nbsp;scripting)</span></p>
<p>
<span>慢日志（slow&nbsp;log)</span></p>
<p>
<span>事件通知（event&nbsp;notification）</span></p>
<p></p>
<p>
<span style="font-weight: bold">二&nbsp;通用</span></p>
<p>
<span>默认情况下，redis并不是以daemon形式来运行的。</span></p>
<p>
<span>daemonize&nbsp;no</span></p>
<p></p>
<p>
<span>当以daemon形式运行时，redis会生成一个pid文件，默认会生成在/var/run/redis.pid。当然，你可以通过pidfile来指定pid文件生成的位置。</span></p>
<p>
<span>pidfile&nbsp;/path/to/redis.pid</span></p>
<p></p>
<p>
<span>默认情况下，redis会响应本机所有可用网卡的连接请求。</span></p>
<p>
<span>bind&nbsp;192.168.1.2&nbsp;10.8.4.2</span></p>
<p></p>
<p>
<span>redis的默认服务端口是6379，你可以通过port配置项来修改。</span></p>
<p>
<span>port&nbsp;6379</span></p>
<p></p>
<p>
<span>有些同学会问&quot;如果redis不监听端口，还怎么与外界通信呢&quot;，其实redis还支持通过unix&nbsp;socket方式来接收请求。可以通过unixsocket配置项来指定unix&nbsp;socket文件的路径，并通过unixsocketperm来指定文件的权限。</span></p>
<p>
<span>unixsocket&nbsp;/tmp/redis.sock</span></p>
<p>
<span>unixsocketperm&nbsp;755</span></p>
<p></p>
<p>
<span>当一个redis-client一直没有请求发向server端，那么server端有权主动关闭这个连接，可以通过timeout来设置&quot;空闲超时时限&quot;，0表示永不关闭。</span></p>
<p>
<span>timeout&nbsp;0</span></p>
<p></p>
<p>
<span>TCP连接保活策略，可以通过tcp-keepalive配置项来进行设置，单位为秒，</span></p>
<p>
<span>假如设置为60秒，则server端会每60秒向连接空闲的客户端发起一次ACK请求，以检查客户端是否已经挂掉，对于无响应的客户端则会关闭其连接。所以关闭一个连接最长需要120秒的时间。</span></p>
<p>
<span>如果设置为0，则不会进行保活检测。</span></p>
<p>
<span>tcp-keepalive&nbsp;0</span></p>
<p></p>
<p>
<span>redis支持通过loglevel配置项设置日志等级，共分四级，即debug、verbose、notice、warning。</span></p>
<p>
<span>loglevel&nbsp;notice</span></p>
<p></p>
<p>
<span>redis也支持通过logfile配置项来设置日志文件的生成位置。如果设置为空字符串，则redis会将日志输出到标准输出。</span></p>
<p>
<span>假如你在daemon情况下将日志设置为输出到标准输出，则日志会被写到/dev/null中。</span></p>
<p>
<span>logfile&nbsp;&quot;&quot;</span></p>
<p></p>
<p>
<span>如果希望日志打印到syslog中，也很容易，通过syslog-enabled来控制。</span></p>
<p>
<span>另外，syslog-ident还可以让你指定syslog里的日志标志，比如：</span></p>
<p>
<span>syslog-ident&nbsp;redis</span></p>
<p></p>
<p>
<span>还支持指定syslog设备，值可以是USER或LOCAL0-LOCAL7。具体可以参考syslog服务本身的用法。</span></p>
<p>
<span>syslog-facility&nbsp;local0</span></p>
<p></p>
<p>
<span>对于redis来说，可以设置其数据库的总数量，假如你希望一个redis包含16个数据库，那么设置如下：</span></p>
<p>
<span>databases&nbsp;16</span></p>
<p>
<span>这16个数据库的编号将是0到15。默认的数据库是编号为0的数据库。用户可以使用select&nbsp;&lt;DBid&gt;来选择相应的数据库。</span></p>
<p>
<span>&nbsp;</span></p>
<p>
<span style="font-weight: bold">三&nbsp;快照&nbsp;</span>
<span>&nbsp;快照，主要涉及的是redis的RDB持久化相关的配置</span></p>
<p>
<span>我们可以用如下的指令来让数据保存到磁盘上，即控制RDB快照功能：</span></p>
<p>
<span>save&nbsp;&lt;seconds&gt;&nbsp;&lt;changes&gt;</span></p>
<p>
<span>save&nbsp;900&nbsp;1&nbsp;//表示每15分钟且至少有1个key改变，就触发一次持久化</span></p>
<p>
<span>save&nbsp;300&nbsp;10&nbsp;//表示每5分钟且至少有10个key改变，就触发一次持久化</span></p>
<p>
<span>save&nbsp;60&nbsp;10000&nbsp;//表示每60秒至少有10000个key改变，就触发一次持久化</span></p>
<p></p>
<p>
<span>如果你想禁用RDB持久化的策略，只要不设置任何save指令就可以，或者给save传入一个空字符串参数也可以达到相同效果</span></p>
<p>
<span>save&nbsp;&quot;&quot;</span></p>
<p></p>
<p>
<span>如果用户开启了RDB快照功能，那么在redis持久化数据到磁盘时如果出现失败，默认情况下，redis会停止接受所有的写请求。</span></p>
<p>
<span>这样做的好处在于可以让用户很明确的知道内存中的数据和磁盘上的数据已经存在不一致了。</span></p>
<p>
<span>如果redis不顾这种不一致，一意孤行的继续接收写请求，就可能会引起一些灾难性的后果。</span></p>
<p>
<span>如果下一次RDB持久化成功，redis会自动恢复接受写请求。</span></p>
<p>
<span>当然，如果你</span>
<span style="font-style: italic">不在乎这种数据不一致</span>
<span>或者</span>
<span style="font-style: italic">有其他的手段发现和控制这种不一致</span>
<span>的话，你完全可以关闭这个功能，以便在快照写入失败时，也能确保redis继续接受新的写请求。配置项如下：</span></p>
<p>
<span>stop-writes-on-bgsave-error&nbsp;yes</span></p>
<p></p>
<p>
<span>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。</span></p>
<p>
<span>rdbcompression&nbsp;yes</span></p>
<p></p>
<p>
<span>在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果你希望获取到最大的性能提升，可以关闭此功能。</span></p>
<p>
<span>rdbchecksum&nbsp;yes</span></p>
<p></p>
<p>
<span>设置快照文件的名称，默认是这样配置的：</span></p>
<p>
<span>dbfilename&nbsp;dump.rdb</span></p>
<p></p>
<p>
<span>可以设置这个快照文件存放的路径。比如默认设置就是当前文件夹：</span></p>
<p>
<span>dir&nbsp;./</span></p>
<p></p>
<p>
<span style="font-weight: bold">四&nbsp;复制&nbsp;</span>
<span>redis提供了主从同步功能。</span></p>
<p>
<span>通过slaveof配置项可以控制某一个redis作为另一个redis的从服务器，通过指定IP和端口来定位到主redis的位置。</span></p>
<p>
<span>一般情况下，我们会建议用户为从redis设置一个不同频率的快照持久化的周期，或者为从redis配置一个不同的服务端口等等。</span></p>
<p>
<span>slaveof&nbsp;&lt;masterip&gt;&nbsp;&lt;masterport&gt;</span></p>
<p></p>
<p>
<span>如果主redis设置了验证密码的话（使用requirepass来设置），则在从redis的配置中要使用masterauth来设置校验密码，否则的话，主redis会拒绝从redis的访问请求。</span></p>
<p>
<span>masterauth&nbsp;&lt;master-password&gt;</span></p>
<p></p>
<p>
<span>当从redis失去了与主redis的连接，或者主从同步正在进行中时，redis该如何处理外部发来的访问请求呢？这里，从redis可以有两种选择：</span></p>
<p>
<span>第一种选择：如果slave-serve-stale-data设置为yes（默认），则从redis仍会继续响应客户端的读写请求。</span></p>
<p>
<span>第二种选择：如果slave-serve-stale-data设置为no，则从redis会对客户端的请求返回&quot;SYNC&nbsp;with&nbsp;master&nbsp;in&nbsp;progress&quot;，当然也有例外，当客户端发来INFO请求和SLAVEOF请求，从redis还是会进行处理。</span></p>
<p>
<span>你可以控制一个从redis是否可以接受写请求。将数据直接写入从redis，一般只适用于那些生命周期非常短的数据，因为在主从同步时，这些临时数据就会被清理掉。、</span></p>
<p>
<span>自从redis2.6版本之后，默认从redis为只读。</span></p>
<p>
<span>slave-read-only&nbsp;yes</span></p>
<p></p>
<p>
<span>只读的从redis并不适合直接暴露给不可信的客户端。为了尽量降低风险，可以使用rename-command指令来将一些可能有破坏力的命令重命名，避免外部直接调用。比如：</span></p>
<p>
<span>rename-command&nbsp;CONFIG&nbsp;b840fc02d524045429941cc15f59e41cb7be6c52</span></p>
<p></p>
<p>
<span>从redis会周期性的向主redis发出PING包。你可以通过repl_ping_slave_period指令来控制其周期。默认是10秒。</span></p>
<p>
<span>repl-ping-slave-period&nbsp;10</span></p>
<p></p>
<p>
<span>在主从同步时，可能在这些情况下会有超时发生：</span></p>
<p>
<span>以从redis的角度来看，当有大规模IO传输时。</span></p>
<p>
<span>以从redis的角度来看，当数据传输或PING时，主redis超时</span></p>
<p>
<span>以主redis的角度来看，在回复从redis的PING时，从redis超时</span></p>
<p>
<span>用户可以设置上述超时的时限，不过要确保这个时限比repl-ping-slave-period的值要大，否则每次主redis都会认为从redis超时</span>
<span>。</span></p>
<p>
<span>repl-timeout&nbsp;60</span></p>
<p></p>
<p>
<span>我们可以控制在主从同步时是否禁用TCP_NODELAY。</span></p>
<p>
<span>如果开启TCP_NODELAY，那么主redis会使用更少的TCP包和更少的带宽来向从redis传输数据。但是这可能会增加一些同步的延迟，大概会达到40毫秒左右。</span></p>
<p>
<span>如果你关闭了TCP_NODELAY，那么数据同步的延迟时间会降低，但是会消耗更多的带宽。</span></p>
<p>
<span>repl-disable-tcp-nodelay&nbsp;no</span></p>
<p></p>
<p>
<span>设置同步队列长度</span></p>
<p>
<span>队列长度（backlog)是主redis中的一个缓冲区，在与从redis断开连接期间，主redis会用这个缓冲区来缓存应该发给从redis的数据。这样的话，当从redis重新连接上之后，就不必重新全量同步数据，只需要同步这部分增量数据即可。</span></p>
<p>
<span>repl-backlog-size&nbsp;1mb</span></p>
<p></p>
<p>
<span>等待的时间长度</span></p>
<p>
<span>如果主redis等了一段时间之后，还是无法连接到从redis，那么缓冲队列中的数据将被清理掉。我们可以设置主redis要等待的时间长度。如果设置为0，则表示永远不清理。默认是1个小时。</span></p>
<p>
<span>repl-backlog-ttl&nbsp;3600</span></p>
<p></p>
<p>
<span>从redis设置优先级</span></p>
<p>
<span>在主redis持续工作不正常的情况，优先级高的从redis将会升级为主redis。</span></p>
<p>
<span>而编号越小，优先级越高。</span></p>
<p>
<span>比如一个主redis有三个从redis，优先级编号分别为10、100、25，那么编号为10的从redis将会被首先选中升级为主redis。</span></p>
<p>
<span>当优先级被设置为0时，这个从redis将永远也不会被选中。默认的优先级为100。</span></p>
<p>
<span>slave-priority&nbsp;100</span></p>
<p></p>
<p>
<span>假如主redis发现有超过M个从redis的连接延时大于N秒，那么主redis就停止接受外来的写请求。</span></p>
<p>
<span>这是因为从redis一般会每秒钟都向主redis发出PING，而主redis会记录每一个从redis最近一次发来PING的时间点，所以主redis能够了解每一个从redis的运行情况。</span></p>
<p>
<span>min-slaves-to-write&nbsp;3&nbsp;M</span></p>
<p>
<span>min-slaves-max-lag&nbsp;10&nbsp;N</span></p>
<p>
<span>上面这个例子表示，假如有大于等于3个从redis的连接延迟大于10秒，那么主redis就不再接受外部的写请求。</span></p>
<p>
<span>上述两个配置中有一个被置为0，则这个特性将被关闭。</span></p>
<p>
<span>默认情况是关闭的。</span></p>
<p></p>
<p>
<span style="font-weight: bold">五&nbsp;安全&nbsp;</span></p>
<p>
<span>设置验证密码</span></p>
<p>
<span>要求redis客户端在向redis-server发送请求之前，先进行密码验证。</span></p>
<p>
<span>当你的redis-server处于一个不太可信的网络环境中时，相信你会用上这个功能。</span></p>
<p>
<span>由于redis性能非常高，所以每秒钟可以完成多达15万次的密码尝试，所以你最好设置一个足够复杂的密码，否则很容易被黑客破解。</span></p>
<p>
<span>requirepass&nbsp;zhimakaimen</span></p>
<p></p>
<p>
<span>redis允许我们对redis指令进行更名，比如将一些比较危险的命令改个名字，避免被误执行。</span></p>
<p>
<span>rename-command&nbsp;CONFIG&nbsp;b840fc02d524045429941cc15f59e41cb7be6c89</span></p>
<p></p>
<p>
<span>我们甚至可以禁用掉CONFIG命令，那就是把CONFIG的名字改成一个空字符串：</span></p>
<p>
<span>rename-command&nbsp;CONFIG&nbsp;&quot;&quot;</span></p>
<p></p>
<p>
<span style="font-weight: bold">但需要注意的是</span>
<span>，如果你使用AOF方式进行数据持久化，或者需要与从redis进行通信，那么更改指令的名字可能会引起一些问题。</span></p>
<p></p>
<p>
<span style="font-weight: bold">六&nbsp;限制</span></p>
<p>
<span>设置客户端连接的数量</span></p>
<p>
<span>我们可以设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。</span></p>
<p>
<span>当你无法设置进程文件句柄限制时，redis会设置为当前的文件句柄限制值减去32，因为redis会为自身内部处理逻辑留一些句柄出来。</span></p>
<p>
<span>如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出&quot;max&nbsp;number&nbsp;of&nbsp;clients&nbsp;reached&quot;以作回应。</span></p>
<p>
<span>maxclients&nbsp;10000</span></p>
<p></p>
<p>
<span>设置redis可以使用的内存量</span></p>
<p>
<span>以设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</span></p>
<p>
<span>maxmemory&nbsp;&lt;bytes&gt;</span></p>
<p></p>
<p>
<span>如果redis无法根据移除规则来移除内存中的数据，或者我们设置了&quot;不允许移除&quot;，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</span></p>
<p>
<span>但是对于无内存申请的指令，仍然会正常响应，比如GET等。</span></p>
<p>
<span>需要注意的一点是，如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是&quot;不移除&quot;的情况下，才不用考虑这个因素。</span></p>
<p></p>
<p>
<span>对于内存移除规则来说，redis提供了多达6种的移除规则。他们是：</span></p>
<p>
<span>volatile-lru：使用LRU算法移除过期集合中的key</span></p>
<p>
<span>allkeys-lru：使用LRU算法移除key</span></p>
<p>
<span>volatile-random：在过期集合中移除随机的key</span></p>
<p>
<span>allkeys-random：移除随机的key</span></p>
<p>
<span>volatile-ttl：移除那些TTL值最小的key，即那些最近才过期的key。</span></p>
<p>
<span>noeviction：不进行移除。针对写操作，只是返回错误信息。</span></p>
<p></p>
<p>
<span style="font-weight: bold">七&nbsp;追加模式</span></p>
<p>
<span>追加文件（Append&nbsp;Only&nbsp;File）是一种更好的保持数据一致性的方式。即使当服务器断电时，也仅会有1秒钟的写请求丢失，当redis进程出现问题且操作系统运行正常时，甚至只会丢失一条写请求。</span></p>
<p>
<span>建议大家，AOF机制和RDB机制可以同时使用，不会有任何冲突。</span></p>
<p>
<span>appendonly&nbsp;no</span></p>
<p></p>
<p>
<span>设置aof文件的名称：</span></p>
<p>
<span>appendfilename&nbsp;&quot;appendonly.aof&quot;</span></p>
<p></p>
<p>
<span>redis支持三种不同的模式：</span></p>
<p>
<span>no：不调用fsync()。而是让操作系统自行决定sync的时间。这种模式下，redis的性能会最快。</span></p>
<p>
<span>always：在每次写请求后都调用fsync()。这种模式下，redis会相对较慢，但数据最安全。</span></p>
<p>
<span>everysec：每秒钟调用一次fsync()。这是性能和安全的折衷。</span></p>
<p>
<span>默认情况下为everysec。</span></p>
<p>
<span>appendfsync&nbsp;everysec</span></p>
<p>
<span>fsync()调用，用来告诉操作系统立即将缓存的指令写入磁盘。一些操作系统会&quot;立即&quot;进行，而另外一些操作系统则会&quot;尽快&quot;进行。</span></p>
<p></p>
<p>
<span>当fsync方式设置为always或everysec时，如果后台持久化进程需要执行一个很大的磁盘IO操作，那么redis可能会在fsync()调用时卡住。</span></p>
<p>
<span>这意味着当另一路进程正在对AOF文件进行重构时，redis的持久化功能就失效了，就好像我们设置了&quot;appendsync&nbsp;none&quot;一样。</span></p>
<p>
<span>如果你的redis有时延问题，那么请将下面的选项设置为yes。否则请保持no，因为这是保证数据完整性的最安全的选择。</span></p>
<p>
<span>no-appendfsync-on-rewrite&nbsp;no</span></p>
<p>
<span>当aof增长到一定规模时，redis会隐式调用BGREWRITEAOF来重写log文件，以缩减文件体积。</span></p>
<p></p>
<p>
<span>redis是这样工作的：redis会记录上次重写时的aof大小。假如redis自启动至今还没有进行过重写，那么启动时aof文件的大小会被作为基准值。这个基准值会和当前的aof大小进行比较。如果当前aof大小超出所设置的增长比例，则会触发重写。另外，你还需要设置一个最小大小，是为了防止在aof很小时就触发重写。</span></p>
<p>
<span>auto-aof-rewrite-percentage&nbsp;100</span></p>
<p>
<span>auto-aof-rewrite-min-size&nbsp;64mb</span></p>
<p>
<span>如果设置auto-aof-rewrite-percentage为0，则会关闭此重写功能。</span></p>
<p></p>
<p>
<span style="font-weight: bold">八&nbsp;LUA脚本</span></p>
<p>
<span>lua脚本的最大运行时间是需要被严格限制的，单位：毫秒</span></p>
<p>
<span>lua-time-limit&nbsp;5000</span></p>
<p>
<span>如果此值设置为0或负数，则既不会有报错也不会有时间限制。</span></p>
<p></p>
<p>
<span>针对慢日志，你可以设置两个参数，一个是执行时长，单位是微秒，另一个是慢日志的长度。</span></p>
<p>
<span>当一个新的命令被写入日志时，最老的一条会从命令日志队列中被移除。</span></p>
<p></p>
<p>
<span>单位是微秒，即1000000表示一秒。负数则会禁用慢日志功能，而0则表示强制记录每一个命令。</span></p>
<p>
<span>slowlog-log-slower-than&nbsp;10000</span></p>
<p></p>
<p>
<span>慢日志最大长度，可以随便填写数值，没有上限，但要注意它会消耗内存。你可以使用SLOWLOG&nbsp;RESET来重设这个值。</span></p>
<p>
<span>slowlog-max-len&nbsp;128</span></p>
<p></p>
<p>
<span style="font-weight: bold">九&nbsp;事件通知</span></p>
<p>
<span>r</span>
<span>edis可以向客户端通知某些事件的发生。</span></p>
<p></p>
<p>
<span style="font-weight: bold">十&nbsp;高级配置</span></p>
<p>
<span>有关哈希数据结构的配置项：</span></p>
<p>
<span>hash-max-ziplist-entries&nbsp;512</span></p>
<p>
<span>hash-max-ziplist-value&nbsp;64</span></p>
<p></p>
<p>
<span>有关列表数据结构配置项：</span></p>
<p>
<span>list-max-ziplist-entries&nbsp;512</span></p>
<p>
<span>list-max-ziplist-value&nbsp;64</span></p>
<p></p>
<p>
<span>有关集合数据结构的配置项：</span></p>
<p>
<span>set-max-intset-entries&nbsp;512</span></p>
<p></p>
<p>
<span>有关有序集合数据结构的配置项：</span></p>
<p>
<span>zset-max-ziplist-entries&nbsp;128</span></p>
<p>
<span>zset-max-ziplist-value&nbsp;64</span></p>
<p></p>
<p>
<span>关于是否需要再哈希的配置项：</span></p>
<p>
<span>activerehashing&nbsp;yes</span></p>
<p></p>
<p>
<span>关于客户端输出缓冲的控制项：</span></p>
<p>
<span>client-output-buffer-limit&nbsp;normal&nbsp;0&nbsp;0&nbsp;0</span></p>
<p>
<span>client-output-buffer-limit&nbsp;slave&nbsp;256mb&nbsp;64mb&nbsp;60</span></p>
<p>
<span>client-output-buffer-limit&nbsp;pubsub&nbsp;32mb&nbsp;8mb&nbsp;60</span></p>
<p></p>
<p>
<span>有关频率的配置项：</span></p>
<p>
<span>hz&nbsp;10</span></p>
<p></p>
<p>
<span>有关重写aof的配置项</span></p>
<p>
<span>aof-rewrite-incremental-fsync&nbsp;yes</span></p>
<p></p></dd>


</dl>

</body>

</html>
